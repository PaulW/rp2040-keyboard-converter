# Unified Scancode Processor (Sets 1, 2, 3)

Keyboards use a specific scancode set, but situations arise where the specific set is uncertain or where keyboard hot-swapping between different scancode sets is desirable without firmware rebuilding. The unified scancode processor addresses these scenarios.

This processor handles all three XT/AT protocol scancode sets (1, 2, and 3) using a configuration-driven approach. A single state machine adapts its behaviour based on the selected scancode set. The primary benefit is keyboard hot-swapping on AT/PS2 protocol converters—keyboards can be swapped and the converter automatically detects and adapts to different scancode sets at runtime.

The key use case is flexibility: swapping between standard PS/2 keyboards (Set 2) and terminal keyboards (Set 3) without firmware changes. This is particularly useful when working with keyboards that might switch sets dynamically or when the scancode set is uncertain.

## Overview

The implementation consists of several key files: [`scancode.h`](../../src/scancodes/set123/scancode.h) with the API and configuration structures, [`scancode.c`](../../src/scancodes/set123/scancode.c) with the unified state machine, [`scancode_config.h`](../../src/scancodes/set123/scancode_config.h) for compile-time XT protocol wrapping (Set 1 only), and [`scancode_runtime.h`](../../src/scancodes/set123/scancode_runtime.h) for runtime detection on AT/PS2 protocol (Set 2/3).

This unified processor coexists with the original per-set implementations. The files [`set1/scancode.c`](../../src/scancodes/set1/scancode.c), [`set2/scancode.c`](../../src/scancodes/set2/scancode.c), and [`set3/scancode.c`](../../src/scancodes/set3/scancode.c) remain fully functional. The unified processor provides flexibility for hot-swapping scenarios, whilst the original implementations remain simpler choices for converters dedicated to specific keyboards.

## Quick Start

```c
#include "scancodes/set123/scancode.h"

void keyboard_interface_task(void) {
    uint8_t code;
    
    if (get_scancode_from_buffer(&code)) {
        // Choose your scancode set:
        process_scancode(code, &SCANCODE_CONFIG_SET2);
    }
}
```

## Configuration Constants

The processor provides three pre-configured constants that define the behaviour for each scancode set: `SCANCODE_CONFIG_SET1` for XT/Set 1 (where breaks are code | 0x80), `SCANCODE_CONFIG_SET2` for PS/2 Set 2 (breaks are F0 + code), and `SCANCODE_CONFIG_SET3` for Terminal Set 3 (also F0 + code for breaks, but without E0/E1 prefixes).

Behaviour is configured via a struct rather than separate code paths. The processor handles E0 and E1 prefix sequences for extended keys and Pause/Break. Fake shift detection is set-specific—the processor filters the appropriate codes for each set. Special code mapping handles F7, SysRq, and Keypad Comma consistently across sets.

Performance matches the individual implementations. The same lookup tables and inline functions are used—the configuration struct determines which table and which rules to apply.  

## Documentation

### Technical Scancode Set References

For detailed technical information about each scancode set:

- **[Set 1 (XT) Technical Documentation](set1.md)** - Encoding, state machine, E0/E1 prefixes, fake shifts
- **[Set 2 (AT/PS2) Technical Documentation](set2.md)** - F0 breaks, extended keys, host commands, LED control
- **[Set 3 (Terminal) Technical Documentation](set3.md)** - Simplified design, no prefixes, make/break mode

## Scancode Set Comparison

The three scancode sets represent the evolution of keyboard protocols. Set 1 (XT) was the original design, Set 2 (AT/PS2) improved upon it, and Set 3 (Terminal) simplified the architecture. Each has distinct characteristics that the unified processor must handle.

The comparison below shows the key differences. Set 3 eliminated E0/E1 prefixes entirely and removed fake shifts, used primarily on terminal keyboards. Set 2 is the default for AT/PS2 keyboards and requires 9 states to handle all prefix combinations. Set 1 has moderate complexity at 5 states.

For comprehensive technical details on each set's encoding, state machines, and special sequences, see the individual set documentation linked in the table:

| Feature | Set 1 | Set 2 | Set 3 |
|---------|-------|-------|-------|
| **Break Encoding** | code \| 0x80 | F0 + code | F0 + code |
| **E0 Prefix** | Yes (23 mappings) | Yes (38 mappings) | No |
| **E1 Prefix** | Yes (Pause) | Yes (Pause) | No |
| **Fake Shifts** | 4 codes | 2 codes | None |
| **State Complexity** | Medium (5 states) | High (9 states) | Low (2 states) |
| **Documentation** | [Set 1 README](set1.md) | [Set 2 README](set2.md) | [Set 3 README](set3.md) |

The unified processor's state machine needs 11 states to handle all three sets—more than any individual set, but still quite manageable. The complexity pays off when you need flexibility.

## Implementation Details

### State Machine

The unified processor's state machine uses 11 states to handle all three sets. For detailed state machine diagrams and explanations specific to each set, see:
- [Set 1 state machine](set1.md#state-machine) (5 states)
- [Set 2 state machine](set2.md#state-machine) (9 states)  
- [Set 3 state machine](set3.md#state-machine) (2 states)

**Unified states:**
```
INIT            - Initial state / ready for next code
F0              - Break prefix (Set 2/3)
E0              - E0 prefix (Set 1/2)
E0_F0           - E0 F0 sequence (Set 2)
E1              - E1 prefix (Set 1/2)
E1_1D           - E1 1D (Set 1 Pause make)
E1_9D           - E1 9D (Set 1 Pause break)
E1_14           - E1 14 (Set 2 Pause make)
E1_F0           - E1 F0 (Set 2 Pause break)
E1_F0_14        - E1 F0 14 (Set 2 Pause break)
E1_F0_14_F0     - E1 F0 14 F0 (Set 2 Pause break)
```

### E0 Translation Tables

For complete E0 scancode mappings and extended key details:
- [Set 1 E0 codes](set1.md#extended-keys-e0-prefix) - 23 mappings
- [Set 2 E0 codes](set2.md#extended-keys-e0-prefix) - 38 mappings
- [Set 3](set3.md#no-extended-keys) - No E0 prefix (all direct codes)

### Fake Shift Handling

For the history and rationale behind fake shift codes:
- [Set 1 fake shifts](set1.md#fake-shift-codes) - E0 2A, AA, 36, B6 (Print Screen compatibility)
- [Set 2 fake shifts](set2.md#fake-shift-codes) - E0 12, E0 F0 12, E0 59 (rare)
- [Set 3](set3.md#no-fake-shifts) - None (eliminated entirely)

### Special Codes

Each set has unique special codes - see individual documentation:
- [Set 1 special codes](set1.md#special-codes)
- [Set 2 special codes](set2.md#special-codes) - 0x83 (F7), 0x84 (SysReq)
- [Set 3 special codes](set3.md#special-codes) - 0x7C (Keypad Comma), 0x83 (F7), 0x84 (Keypad Plus)

## Benefits of Unified Processor

The primary advantage here is hot-swappable keyboards. The unified processor enables AT/PS2 converters to automatically adapt to different keyboard types. You can swap between standard PS/2 keyboards (Set 2) and terminal keyboards (Set 3) without rebuilding firmware. The converter detects the scancode set at runtime and configures itself accordingly. A single binary supports multiple keyboard types, which is particularly handy if you're building a universal converter or testing different keyboards.

Beyond flexibility, there are practical maintenance benefits. Bug fixes and improvements go in one place rather than three separate implementations. Behaviour stays consistent across all scancode sets because they're using the same core logic. Code duplication gets reduced—the unified processor consolidates the logic from three separate implementations into a single configuration-driven codebase.

The configuration-driven design also simplifies testing. Rather than testing three separate codebases, you test one implementation with three different configurations. It's easier to verify consistency and catch edge cases that might behave differently between sets.

## Choosing Between Unified and Individual Processors

So which approach should you use? It depends on what you're building.

The unified processor (set123) makes sense when you're building a universal AT/PS2 converter that needs to support multiple keyboard types. It's the right choice if you want runtime keyboard detection and hot-swapping capability, if you're supporting both standard PS/2 and terminal keyboards, or if you prefer maintaining a single codebase rather than multiple implementations. The flexibility is worth the slightly more complex state machine.

The individual processors (set1/set2/set3) are better when you're building a converter for one specific keyboard and don't need the flexibility. If you're optimising for absolute minimal code size, a focused implementation for your specific set will be slightly smaller. You might also prefer individual processors if you want a simpler, more focused implementation, or if you're working with legacy code that already uses the original processors.

Both approaches are perfectly valid—choose based on your use case. The unified processor is about flexibility, whilst the individual processors are about simplicity and focus. Neither is "better" in absolute terms; they solve different problems.

## Fallback to Individual Set

If you encounter issues with the unified processor, you can easily revert to individual set implementations:

1. **Edit your keyboard's config file** (`keyboards/<keyboard>/keyboard.config`):
   ```
   # Change from:
   CODESET=set123
   
   # To one of:
   CODESET=set1   # For XT keyboards
   CODESET=set2   # For standard PS/2 keyboards
   CODESET=set3   # For terminal keyboards
   ```

2. **Rebuild** - The build system will automatically use the original implementation

3. **Test** - Verify keyboard functionality with the individual processor

The original per-set implementations are fully maintained and remain the fallback option if needed.

## Performance

**No overhead compared to original implementations:**
- Same O(1) lookup tables
- Inline helper functions
- Static const configuration (~4 bytes stack overhead)
- No dynamic allocation
- No runtime branching overhead

## Why Not Include Apple M0110?

Apple M0110 uses a completely different protocol family:
- No E0/E1 prefixes
- Different encoding scheme
- Different timing requirements
- Separate protocol family (not XT/AT/PS2)

**Philosophy:** Consolidate within protocol families (XT/AT/PS2), not across different protocol families. See [Apple M0110 protocol documentation](../protocols/m0110.md) for details.

## Technical Encoding References

For in-depth understanding of each scancode set's encoding, sequences, and special cases:

- **[Set 1 Technical Details](set1.md)** - XT encoding, high-bit breaks, E0/E1 sequences, 6-byte Pause
- **[Set 2 Technical Details](set2.md)** - F0 breaks, E0 extended keys, 8-byte Pause, host commands
- **[Set 3 Technical Details](set3.md)** - Simplified design, no prefixes, 2-state machine

These documents provide comprehensive technical specifications independent of this keyboard converter implementation.

## Source Code

- **[`scancode.h`](../../src/scancodes/set123/scancode.h)** - Unified processor API and configuration structures
- **[`scancode.c`](../../src/scancodes/set123/scancode.c)** - Configuration-driven state machine implementation
- **[`scancode_config.h`](../../src/scancodes/set123/scancode_config.h)** - Compile-time configuration for XT protocol
- **[`scancode_runtime.h`](../../src/scancodes/set123/scancode_runtime.h)** - Runtime detection for AT/PS2 protocol
- **[Set 1 Implementation](../../src/scancodes/set1/)** - Original Set 1 processor
- **[Set 2 Implementation](../../src/scancodes/set2/)** - Original Set 2 processor
- **[Set 3 Implementation](../../src/scancodes/set3/)** - Original Set 3 processor

---

## Related Documentation

- [Scancode Set 1](set1.md) - XT scancode set
- [Scancode Set 2](set2.md) - AT/PS2 scancode set
- [Scancode Set 3](set3.md) - Terminal keyboard scancode set
- [Protocols Overview](../protocols/README.md) - All supported protocols
- [Architecture](../advanced/README.md) - System architecture and scancode processing

---

**Questions or stuck on something?**  
Pop into [GitHub Discussions](https://github.com/PaulW/rp2040-keyboard-converter/discussions) or [report a bug](https://github.com/PaulW/rp2040-keyboard-converter/issues) if you've found an issue.
