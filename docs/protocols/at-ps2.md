# AT/PS2 Protocol

The AT/PS2 protocol is a bidirectional, synchronous serial communication protocol used in PC keyboards and mice. Originally developed for the IBM PC/AT keyboard, it was later standardized with the PS/2 connector and became the universal interface for both keyboards and mice until USB adoption.

---

## Historical Context

The AT/PS2 protocol evolved from earlier unidirectional keyboard protocols. Early PC keyboards transmitted scancodes one-way with no LED control, host-to-device communication, or error recovery.

The IBM PC/AT introduced a bidirectional keyboard interface. The computer could send commands to the keyboard for LED control, scancode set selection, and retransmission requests. This bidirectional capability became the defining characteristic of the AT protocol.

The PS/2 connector standardized the interface with a compact 6-pin mini-DIN design, replacing the AT keyboard's 5-pin DIN connector. The protocol remained electrically identical to the AT specification—only the physical connector changed. This is why the protocol is often referred to as "AT/PS2" interchangeably.

Whilst USB keyboards use their own HID scancode system, the AT/PS2 protocol remains relevant in BIOS/UEFI environments where USB support may not be fully initialised. Many systems rely on PS/2 compatibility for pre-boot keyboard access.

---

## Protocol Overview

### Key Characteristics

The AT/PS2 protocol includes bidirectional communication capabilities not present in the earlier XT protocol.

**Bidirectional Communication**: Both the host computer and the device (keyboard or mouse) can initiate communication:
- Host commands: LED control, configuration changes, device identification requests
- Device responses: Acknowledgments, error codes, status information
- Error recovery: The host can request retransmission if parity errors occur

**Synchronous Serial Protocol**: Data transmission is synchronized to a clock signal, ensuring reliable timing:
- **Clock**: Generated by the device (keyboard/mouse), not the host
- **Data**: Sampled on clock edges, providing noise immunity
- **Frame-Based**: Each byte transmitted as an 11-bit frame with start, parity, and stop bits

**Open-Drain Signalling**: Both CLOCK and DATA lines use open-drain outputs with pull-up resistors:
- Either device can pull lines LOW (active drive)
- Neither device drives lines HIGH (passive pull-up)
- This allows bidirectional communication without direction control signals
- Prevents bus conflicts—if both devices drive LOW simultaneously, no damage occurs

**Error Detection**: Odd parity bit for data integrity:
- Parity calculated over 8 data bits
- Receiver verifies parity and can request retransmission on error
- Framing errors detected by invalid start/stop bits

**Flow Control**: Hardware-level inhibit mechanism:
- Host can hold CLOCK LOW indefinitely to prevent device transmission
- Device acknowledges host commands by briefly pulling DATA LOW
- Simple handshaking without complex protocols

---

## Physical Interface

### Connectors and Pinouts

The AT/PS2 interface uses two connector types with identical electrical characteristics:

**PS/2 Connector (6-pin mini-DIN)**

![PS/2 Connector Pinout](../images/connectors/kbd_connector_ps2.png)

*Image credit: [KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/conn/index.html)*

AT/PS2 keyboards and all PS/2 mice use this connector. The compact mini-DIN connector has a reliable mechanical connection with positive locking.

**Pinout** (looking at female socket on cable):
- Pin 1: DATA - Data line (open-drain, bidirectional)
- Pin 2: N/C - Not connected (reserved for future use)
- Pin 3: GND - Ground (0V reference)
- Pin 4: VCC - Power supply (+5V, typically 100-150mA)
- Pin 5: CLOCK - Clock line (open-drain, bidirectional)
- Pin 6: N/C - Not connected (reserved for future use)

**Color Coding** (on PC motherboards):
- **Purple** connector: Keyboard
- **Green** connector: Mouse
- Electrically identical—color only indicates intended use

---

**DIN-5 Connector (180° or 240°)** - Original AT keyboards

![IBM PC/XT/AT DIN-5 Connector Pinout](../images/connectors/kbd_connector_ibmpc.png)

*Image credit: [KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/conn/index.html)*

Larger 5-pin DIN connector used before PS/2 standardization. Two variants exist with different pin arrangements (180° and 240°).

**Pinout** (both variants):
- Pin 1: CLOCK - Clock line
- Pin 2: DATA - Data line  
- Pin 3: N/C - Not connected (or +5V reset on some keyboards)
- Pin 4: GND - Ground
- Pin 5: VCC - Power supply (+5V)

**Important**: 180° and 240° DIN connectors are NOT mechanically interchangeable—the plug will not physically fit the wrong socket. Always verify which type your keyboard uses before ordering connectors.

---

**Terminal Keyboard Connectors**

Terminal keyboards may use specialized connectors with different pinouts from standard PC keyboards:

**240° DIN-5 Terminal Connector**

![Terminal 240° DIN-5 Connector Pinout](../images/connectors/kbd_connector_ibm3179_318x_319x.png)

*Image credit: [KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/conn/index.html)*

**Pinout**:
- Pin 1: VCC - Power supply (+5V)
- Pin 2: GND - Ground
- Pin 3: PE - Protective Earth (not used by converter)
- Pin 4: DATA - Data line
- Pin 5: CLOCK - Clock line

**RJ45 Terminal Connector**

![Terminal RJ45 Connector Pinout](../images/connectors/kbd_connector_ibmterm.png)

*Image credit: [KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/conn/index.html)*

**Pinout**:
- Pin 1: N/C - Not connected
- Pin 2: N/C - Not connected
- Pin 3: VCC - Power supply (+5V)
- Pin 4: DATA - Data line
- Pin 5: CLOCK - Clock line
- Pin 6: GND - Ground
- Pin 7: PE - Protective Earth (not used by converter)
- Pin 8: N/C - Not connected

### Electrical Characteristics

**Logic Levels:**
- **LOW (logic 0)**: 0V to 0.8V
- **HIGH (logic 1)**: 2.0V to 5.5V (typically 5V with pull-ups)
- **Open-Drain**: Neither device actively drives HIGH; pull-up resistors provide HIGH level

**Pull-up Resistors:**
- **Value**: 10kΩ typical (5kΩ to 22kΩ acceptable range)
- **Location**: Usually on motherboard (host side)
- **Purpose**: Return lines to HIGH when neither device drives LOW

**Timing Specifications:**
- **Clock Frequency**: 10-16.7 kHz typical (most devices ~12 kHz)
- **Clock Period**: 60-100µs per bit
- **Clock Pulse Width**: Minimum 30µs per IBM specification
- **Data Setup/Hold**: Minimum 5µs before/after clock edge
- **Frame Spacing**: Minimum 50µs between consecutive frames
- **Host Inhibit**: 96µs typical (CLOCK held LOW to stop device transmission, must exceed bit period)

**Power Requirements:**
- **Voltage**: +5V ±5% (4.75V to 5.25V)
- **Current**: 
  - Keyboard: 50-150mA typical (peak may reach 275mA during startup)
  - Mouse: 10-100mA typical
  - Combined: < 300mA total (well within USB 500mA limit)

**Signal Integrity Considerations:**
- **Cable Length**: Up to 6 meters typical (20 feet)—longer cables may require termination or buffering
- **Capacitance**: Keep total CLOCK/DATA capacitance below 1000pF for reliable operation
- **EMI Protection**: Shielded cables recommended for long runs or electrically noisy environments
- **Connector Durability**: PS/2 connectors rated for 1,000+ insertion cycles

---

## Communication Protocol

### Frame Structure

Every data transmission—whether keyboard scancodes, mouse movement, commands, or responses—uses the same 11-bit frame format. This consistent format works with all devices.

**Frame Composition:**

```
Bit:     0  |  1  2  3  4  5  6  7  8 | 9  | 10
Content: S  | D0 D1 D2 D3 D4 D5 D6 D7 | P  | s

S  = Start Bit (always 0)
D0-D7 = Data Bits (LSB-first: D0 transmitted first, D7 last)
P  = Parity Bit (odd parity over D0-D7)
s  = Stop Bit (always 1)
```

**Bit Timing:**
- Each bit period: 60-100µs (1 clock cycle)
- Total frame time: ~1.1ms (11 bits × 100µs)
- Maximum data rate: ~900 bytes/second (rarely achieved—typical rates much lower)

**Start Bit (0):**
- Always logic 0 (DATA line pulled LOW)
- Signals beginning of frame
- Receiver synchronizes to falling edge of CLOCK when DATA is LOW

**Data Bits (D0-D7):**
- Transmitted LSB-first (least significant bit first)
- D0 sent first, D7 sent last
- Sampled by receiver on falling edge of CLOCK
- Bit order example: To send 0x1C (00011100 binary), transmit: 0-0-1-1-1-0-0-0

**Parity Bit (P):**
- Odd parity calculated over data byte
- Total number of 1-bits (data bits + parity bit) must be odd
- Example calculation:
  ```c
  uint8_t parity = 0;
  for (int i = 0; i < 8; i++) {
      if (data & (1 << i)) parity++;
  }
  parity_bit = (parity & 1) ^ 1;  // XOR with 1 to ensure odd count
  ```
- **Implementation Note**: This converter uses a precomputed 256-byte lookup table ([`interface_parity_table`](../../src/protocols/at-ps2/common_interface.c)) for O(1) parity calculation instead of runtime computation
- Example: For data 0x1C (3 ones), parity bit = 0 (3 is already odd)

**Stop Bit (1):**
- Always logic 1 (DATA line HIGH)
- Signals end of frame
- Creates idle time before next frame
- Some early devices may use 0 (non-standard)—implementation should handle both

### Device-to-Host Communication (Normal Operation)

When a keyboard sends a scancode or a mouse sends movement data, the device controls the clock and timing.

**Timing Diagram:**

```
      ____ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ A _ B _____
CLOCK     \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
      ___     ___ ___ ___ ___ ___ ___ ___ ___ ___ ________
DATA     \___/___X___X___X___X___X___X___X___X___/
           S   D0  D1  D2  D3  D4  D5  D6  D7  P   s

Legend:
CLOCK   = Clock line (device generates pulses)
DATA  = Data line (device sets value before each clock edge)
S     = Start bit (0)
D0-D7 = Data bits (LSB-first)
P     = Parity bit
s     = Stop bit (1)
```

**Transmission Sequence:**

1. **Idle State**: Both CLOCK and DATA are HIGH (pulled up by resistors)

2. **Frame Start**:
   - Device pulls DATA LOW (start bit = 0)
   - Device pulls CLOCK LOW (begin first clock pulse)
   - Host detects falling CLOCK edge, samples DATA (reads start bit)

3. **Data Transmission**:
   - For each of 8 data bits (D0-D7):
     - Device sets DATA to bit value (0 or 1)
     - Device releases CLOCK HIGH (rising edge)
     - **Critical timing**: DATA must be stable 5µs before falling CLOCK edge
     - Device pulls CLOCK LOW (falling edge)
     - Host samples DATA on falling CLOCK edge
     - Repeat for next bit

4. **Parity Bit**:
   - Device sets DATA to parity value
   - Device generates CLOCK pulse
   - Host samples parity on falling CLOCK edge
   - Host verifies parity matches data

5. **Stop Bit**:
   - Device sets DATA HIGH (stop bit = 1)
   - Device generates final CLOCK pulse
   - Host samples stop bit on falling CLOCK edge

6. **Return to Idle**:
   - Device releases both CLOCK and DATA
   - Pull-ups return lines to HIGH
   - Frame complete, ready for next transmission

**Error Conditions:**
- **Parity Error**: Host requests retransmission (sends 0xFE Resend command)
- **Framing Error**: Invalid start or stop bit—frame discarded, possible Resend request
- **Timeout**: If no data received within expected time, host may reset communication

### Host-to-Device Communication (Commands)

When the host needs to send commands (LED control, configuration, device ID request), it must "seize" the bus from the device. This is less common but needed for bidirectional functionality.

Normally, the device controls the clock. To send commands, the host must signal its intent, wait for the device to yield control, then transmit data synchronized to the device's clock (device still generates clock pulses even while receiving).

**Timing Diagram:**

```
      __ I__R _ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ A __ B _____
CLOCK   \____/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/  \_/
      ______     ___ ___ ___ ___ ___ ___ ___ ___ ______     ____
DATA        \___/___X___X___X___X___X___X___X___X___/  \___/
         H   I R  D0  D1  D2  D3  D4  D5  D6  D7  P   s ACK

Legend:
H     = Host/Idle state (both lines HIGH)
I     = Inhibit phase (CLOCK held LOW by host, ~96µs)
R     = Request-to-Send (DATA LOW, CLOCK released, doubles as start bit)
D0-D7 = Data bits (LSB-first)
P     = Parity bit  
s     = Stop bit
ACK   = Device acknowledgment (DATA briefly pulled LOW)
```

**Transmission Sequence:**

**Phase 1: Inhibit** (~96µs)
- **Purpose**: Signal to device that host wants to transmit
- Host pulls CLOCK LOW (inhibits device transmission)
- Duration: ~96µs (must exceed typical bit period of 60-100µs)
- Device stops any pending transmission when it detects sustained CLOCK LOW
- Host maintains DATA HIGH during inhibit

**Phase 2: Request-to-Send**
- Host pulls DATA LOW (serves dual purpose: RTS signal and start bit)
- Host releases CLOCK (returns HIGH via pull-up)
- Device detects CLOCK HIGH with DATA LOW—recognizes host wants to send
- Device prepares to receive and begins generating clock pulses

**Phase 3: Data Transmission**
- Device generates clock pulses (device still controls clock timing)
- Host places data bits on DATA line before each clock falling edge
- 8 data bits transmitted LSB-first (D0 first, D7 last)
- Host places parity bit after last data bit
- Host maintains timing: DATA stable 5µs before clock edge

**Phase 4: Stop Bit**
- Host sets DATA HIGH (stop bit = 1)
- Device generates clock pulse
- Device samples stop bit

**Phase 5: Acknowledgment**
- Host releases DATA (sets to input mode)
- Device briefly pulls DATA LOW (~50µs)—this is the ACK response
- Device releases DATA (returns HIGH)
- ACK LOW pulse confirms device successfully received command

**Phase 6: Response** (if command expects data)
- Device may send response byte(s) using normal device-to-host protocol
- Example: 0xF2 (Get Device ID) command → device responds with ID bytes
- Host processes response, may send additional commands

**RP2040 Implementation:**

The PIO implementation ([`interface.pio`](../../src/protocols/at-ps2/interface.pio)) handles the complete transmission sequence:

```pio
bitLoopOut:
    ; Inhibit Phase: Drive both CLOCK and DATA LOW for ~96µs
    ; Clock divider 750 → 6µs per cycle, 16 cycles = 96µs
    set pindirs 3 [15]  ; Set both DATA (Pin 0) and CLOCK (Pin 1) to output
    set pins, 0 [15]    ; Drive both LOW: CLOCK=Inhibit, DATA=RTS/Start Bit

    ; Release CLOCK, keep DATA LOW
    ; Keyboard detects CLOCK release and begins generating clock pulses
    set pindirs 1       ; CLOCK → input (released HIGH), DATA → output (LOW)

    ; Send 8 data bits + 1 parity bit (9 total from OSR, LSB first)
    ; Start bit (0) is implicit in DATA LOW state from RTS phase
    set x, 8

bitLoopOutLoop:
    ; Wait for keyboard to generate clock edges, output data bits LSB-first
    wait 0 pin 1 [1]
    out pins, 1         ; Output next bit from OSR to DATA (Pin 0)
    wait 1 pin 1
    jmp x--, bitLoopOutLoop

    ; Send Stop bit (DATA HIGH)
    wait 0 pin 1 [1]
    set pins, 1         ; Drive DATA HIGH (Stop Bit = 1)
    wait 1 pin 1

    ; Wait for ACK (keyboard pulls DATA LOW briefly)
    set pindirs, 0      ; Release DATA (set to input to read ACK)
    wait 0 pin 0 [1]
    wait 1 pin 0 [5]    ; Extra delay [5] for keyboard timing variations

    ; Transmission complete, return to idle
    jmp check
```

**Special Cases:**

**Variant Keyboards** (e.g., Zenith Z-150):
- Some keyboards have irregular ACK timing
- ACK may be delayed or clock may stop briefly
- Implementation should timeout gracefully (15ms) and retry if needed

**Device Not Ready**:
- If device doesn't respond to inhibit, host timeout (~20ms)
- Retry mechanism: Re-attempt inhibit sequence up to 3 times
- Ultimate fallback: Device reset (send 0xFF command)

---

## Keyboard Implementation

### Keyboard-Specific Features

While the underlying protocol is shared, keyboards have unique commands, data formats, and behaviors that distinguish them from mice.

### Scancode Sets

AT/PS2 keyboards support three different scancode sets (also called translation tables). These define how physical key presses map to transmitted byte values.

**Set 1 (XT-Compatible)**:
- Inherited from original IBM PC/XT protocol
- Make code: Single byte for most keys (0x01-0x59)
- Break code: Make code + 0x80 (e.g., 0x1C → 0x9C)
- Extended keys: Prefix 0xE0 before scancode
- Used by: Some older keyboards, BIOS/firmware for compatibility

**Set 2 (Default)**:
- Default for PS/2 keyboards
- Make code: 1-2 bytes (base scancode or 0xE0 + scancode)
- Break code: 0xF0 + make code (e.g., 0x1C → 0xF0 0x1C)
- Extended keys: 0xE0 prefix (some keys: 0xE0 0xF0 for break)
- Pause key: Special 8-byte sequence (0xE1 0x14 0x77 ...)
- Flexible configuration

**Set 3 (Terminal Keyboards)**:
- Designed for simplicity and consistency
- Make/break structure: All keys have 1-byte make, 1-byte break (0xF0 + make)
- No extended prefixes for most keys
- Used by: Terminal keyboards (Various ISO/ANSI and 122-key models like IBM 3179, 318x, 319x)
- Less common in PC keyboards, but standard for terminal applications

**Selecting Scancode Set:**
```
Host sends: 0xF0 (Set Scancode Set command)
Device responds: 0xFA (ACK)
Host sends: 0x02 (Set 2) or 0x01 (Set 1) or 0x03 (Set 3)
Device responds: 0xFA (ACK)
```

**Query Current Set:**
```
Host sends: 0xF0 (Set Scancode Set command)
Device responds: 0xFA (ACK)
Host sends: 0x00 (Query)
Device responds: 0xFA (ACK), then current set number (0x01/0x02/0x03)
```

**Note**: Not all keyboards support the query command (0xF0 0x00). Some keyboards may return incorrect values or fail to respond. It's often more reliable to explicitly set the desired scancode set rather than relying on the query function.

### LED Control

AT/PS2 keyboards typically have three LED indicators that the host controls via commands. These show lock key states (Caps Lock, Num Lock, Scroll Lock).

**LED State Byte Format:**

```
Bit 7 6 5 4 3 2 1 0
    - - - - - S N C

C = Caps Lock LED (1 = on, 0 = off)
N = Num Lock LED (1 = on, 0 = off)
S = Scroll Lock LED (1 = on, 0 = off)
Bits 3-7 = Reserved (should be 0)
```

**LED Control Sequence:**

```
Host sends: 0xED (Set LEDs command)
Device responds: 0xFA (ACK)
Host sends: LED state byte (e.g., 0x07 = all LEDs on)
Device responds: 0xFA (ACK)
LEDs: Update to reflect new state
```

**Examples:**

| State | Byte | LEDs |
|-------|------|------|
| All off | 0x00 | Caps:OFF, Num:OFF, Scroll:OFF |
| Caps Lock only | 0x04 | Caps:ON, Num:OFF, Scroll:OFF |
| Num Lock only | 0x02 | Caps:OFF, Num:ON, Scroll:OFF |
| Caps + Num | 0x06 | Caps:ON, Num:ON, Scroll:OFF |
| All on | 0x07 | Caps:ON, Num:ON, Scroll:ON |

**Implementation Notes:**
- LED updates should be non-blocking (don't wait for ACK in main loop)
- Queue LED commands to avoid interfering with scancode reception
- Some keyboards may take 10-20ms to update LEDs—don't flood with rapid changes
- If ACK not received within 20ms, retry once then skip (degraded mode)

### Keyboard Commands

**Common Commands:**

| Command | Value | Parameters | Response | Description |
|---------|-------|------------|----------|-------------|
| **Set LEDs** | 0xED | LED state byte | ACK, ACK | Control Caps/Num/Scroll Lock LEDs |
| **Echo** | 0xEE | None | 0xEE | Diagnostic test—keyboard echoes command |
| **Set Scancode Set** | 0xF0 | Set number (0/1/2/3) | ACK, ACK/set# | Change or query scancode set |
| **Get Device ID** | 0xF2 | None | ACK, ID bytes | Request keyboard identification |
| **Set Typematic** | 0xF3 | Rate/delay byte | ACK, ACK | Configure auto-repeat rate and delay |
| **Enable** | 0xF4 | None | ACK | Enable key scanning |
| **Disable** | 0xF5 | None | ACK | Disable key scanning (except 0xFF) |
| **Set Defaults** | 0xF6 | None | ACK | Restore factory default settings |
| **Resend** | 0xFE | None | Previous byte | Request retransmission of last byte |
| **Reset** | 0xFF | None | ACK, 0xAA, ID | Full device reset + self-test |

**Device Responses:**

| Response | Value | Meaning |
|----------|-------|---------|
| **ACK** | 0xFA | Command acknowledged, executed successfully |
| **Resend** | 0xFE | Request retransmit—parity error or command not understood |
| **Error** | 0xFC | Internal error or buffer overflow |
| **BAT Passed** | 0xAA | Basic Assurance Test completed successfully (after reset) |
| **BAT Failed** | 0xFC | Basic Assurance Test failed (rare, indicates hardware problem) |

### Keyboard Initialisation Sequence

**Power-On Self-Test (POST):**

```
1. Device powers on
2. Device performs internal self-test (~500ms)
3. Device sends 0xAA (BAT passed) or 0xFC (BAT failed)
4. Device sends 2-byte ID (e.g., 0xAB 0x83 for enhanced keyboard)
5. Device enters idle state, ready to send scancodes
```

**Host Initialisation (Typical):**

```
1. Wait for BAT completion (0xAA received)
2. Send 0xF2 (Get Device ID) to confirm keyboard present
3. Wait for ACK + ID bytes
4. Send 0xF0 0x00 (Query scancode set) to determine current mode
5. Optional: Send 0xF0 0x02 (Set to scancode set 2) for consistency
6. Send 0xF4 (Enable) to start scancode transmission
7. Begin processing scancodes from keyboard
```

**Graceful Handling of Hot-Plug** (Not Recommended, but possible):

While hot-swapping keyboards can cause state machine issues, the converter provides defense-in-depth protection:

**Protocol Layer Filtering:**
- During initialization (UNINITIALISED, INIT_AWAIT_SELFTEST states), the protocol layer filters self-test codes (0xAA, 0xFC)
- Once INITIALISED, all codes pass through to the scancode layer

**Scancode Layer Defense-in-Depth:**
- Provides additional filtering for post-initialization scenarios (hot-plug, unstable connections)
- Set 1 explicitly blacklists 0xAA/0xFC to prevent collision with valid scancodes (see [Set 1 Self-Test Code Collision](../scancodes/set1.md#self-test-code-collision))
- Set 2/3 log these codes as potential re-plug events but don't process them as key events

**What This Doesn't Provide:**
- No active hot-swap detection (monitoring for unexpected 0xAA to trigger re-initialization)
- No automatic scancode processor state reset on detection
- No re-running of full initialization sequence

**Graceful detection approach (if implemented):**
- Monitor for unexpected 0xAA (indicates device reset/reconnection)
- On detection: Re-run initialisation sequence
- Clear scancode processor state (discard any partial multi-byte sequences)

### Keyboard Device IDs

| Device Type | ID Bytes | Description |
|-------------|----------|-------------|
| **Standard AT** | 0xAB 0x41 | Basic AT keyboard (83-key) |
| **Enhanced AT/PS2** | 0xAB 0x83 | Enhanced keyboard (101/104-key) |
| **Japanese** | 0xAB 0x90 or 0xAB 0x91 | Japanese layout variations |
| **NCD N-97** | 0xAF 0xBF | NCD N-97 keyboard (rare) |
| **Unknown** | Various | Non-standard keyboards may return different IDs |

**Note**: Some keyboards may return 0x00 or fail to respond to ID requests. In such cases, fallback to default assumptions (e.g., assume enhanced keyboard) may be necessary for compatibility.

---

## Mouse Implementation

### Mouse-Specific Features

While using the same underlying AT/PS2 protocol, mice have distinct packet formats, command sets, and operational modes.

### Mouse Types and Packet Formats

**Standard PS/2 Mouse (3-byte packets):**

The most basic mouse type, supporting position tracking and three buttons.

```
Packet format:
┌────────┬────────┬────────┐
│ Byte 1 │ Byte 2 │ Byte 3 │
│ Status │   X    │   Y    │
└────────┴────────┴────────┘

Byte 1 (Status):
Bit 7: Y overflow (1 = movement > ±255)
Bit 6: X overflow (1 = movement > ±255)
Bit 5: Y sign (1 = negative)
Bit 4: X sign (1 = negative)
Bit 3: Always 1 (packet identifier)
Bit 2: Middle button (1 = pressed)
Bit 1: Right button (1 = pressed)
Bit 0: Left button (1 = pressed)

Byte 2 (X Movement):
Signed 8-bit value: -128 to +127 (with sign in Byte 1 bit 4)
Positive = right, Negative = left
Combined with sign bit: -255 to +255 range

Byte 3 (Y Movement):
Signed 8-bit value: -128 to +127 (with sign in Byte 1 bit 5)
Positive = up, Negative = down  
Combined with sign bit: -255 to +255 range
```

**IntelliMouse (4-byte packets):**

Microsoft IntelliMouse added a scroll wheel, requiring extended packet format.

```
Packet format:
┌────────┬────────┬────────┬────────┐
│ Byte 1 │ Byte 2 │ Byte 3 │ Byte 4 │
│ Status │   X    │   Y    │   Z    │
└────────┴────────┴────────┴────────┘

Bytes 1-3: Same as standard mouse
Byte 4 (Z Movement / Scroll Wheel):
Signed 8-bit value: -128 to +127
Positive = scroll up/away from user
Negative = scroll down/toward user
Typical values: ±1 per scroll wheel detent
```

**IntelliMouse Explorer (4-byte packets with extra buttons):**

Added two extra buttons (Button 4 and Button 5) for web navigation.

```
Packet format:
┌────────┬────────┬────────┬────────┐
│ Byte 1 │ Byte 2 │ Byte 3 │ Byte 4 │
│ Status │   X    │   Y    │ Z+Btn  │
└────────┴────────┴────────┴────────┘

Bytes 1-3: Same as standard mouse
Byte 4 (Z Movement + Extra Buttons):
Bit 7-4: Scroll wheel movement (signed 4-bit: -8 to +7)
Bit 3-2: Reserved (usually 0)
Bit 1: Button 5 (1 = pressed)
Bit 0: Button 4 (1 = pressed)

Note: Reduced scroll wheel resolution (4-bit vs 8-bit)
```

### Mouse Type Detection

Mice identify themselves differently from keyboards and require special "magic" sequences to enable IntelliMouse modes.

**Detection Sequence:**

```
1. Power-on: Mouse sends 0xAA (BAT passed), then 0x00 (device ID)
2. Host sends: 0xF2 (Get Device ID)
3. Mouse responds: 0xFA (ACK), then 0x00 (standard mouse)
4. To enable IntelliMouse mode (scroll wheel):
   a. Set sample rate 200: 0xF3, 0xFA, 0xC8, 0xFA
   b. Set sample rate 100: 0xF3, 0xFA, 0x64, 0xFA
   c. Set sample rate 80:  0xF3, 0xFA, 0x50, 0xFA
   d. Get ID: 0xF2, 0xFA, 0x03 (now reports as IntelliMouse)
5. To enable IntelliMouse Explorer (5 buttons):
   a. Set sample rate 200: 0xF3, 0xFA, 0xC8, 0xFA
   b. Set sample rate 200: 0xF3, 0xFA, 0xC8, 0xFA
   c. Set sample rate 80:  0xF3, 0xFA, 0x50, 0xFA
   d. Get ID: 0xF2, 0xFA, 0x04 (now reports as Explorer)
```

**This Project's Approach:**

The converter automatically detects and switches to the highest supported mouse mode:
1. Attempt IntelliMouse Explorer detection (200-200-80 sequence)
2. If ID = 0x04: Use 4-byte Explorer format
3. If ID ≠ 0x04: Attempt standard IntelliMouse (200-100-80 sequence)
4. If ID = 0x03: Use 4-byte IntelliMouse format
5. If ID = 0x00: Use 3-byte standard format
6. Store detected mode for packet processing

### Mouse Commands

| Command | Value | Parameters | Response | Description |
|---------|-------|------------|----------|-------------|
| **Set Scaling 1:1** | 0xE6 | None | ACK | Disable acceleration (linear movement) |
| **Set Scaling 2:1** | 0xE7 | None | ACK | Enable 2:1 acceleration at high speeds |
| **Set Resolution** | 0xE8 | Resolution code | ACK, ACK | Set counts per mm (0-3) |
| **Status Request** | 0xE9 | None | ACK, 3 bytes | Request mouse status information |
| **Set Stream Mode** | 0xEA | None | ACK | Enable continuous data reporting |
| **Read Data** | 0xEB | None | ACK, packet | Request single data packet (remote mode) |
| **Set Remote Mode** | 0xF0 | None | ACK | Disable continuous reporting |
| **Get Device ID** | 0xF2 | None | ACK, ID byte | Request mouse identification |
| **Set Sample Rate** | 0xF3 | Rate (10-200 Hz) | ACK, ACK | Set reporting frequency |
| **Enable Reporting** | 0xF4 | None | ACK | Start sending movement data |
| **Disable Reporting** | 0xF5 | None | ACK | Stop sending movement data |
| **Set Defaults** | 0xF6 | None | ACK | Restore factory settings |
| **Resend** | 0xFE | None | Previous byte | Request retransmission |
| **Reset** | 0xFF | None | ACK, 0xAA, ID | Full device reset + self-test |

**Resolution Codes** (for 0xE8 Set Resolution):

| Code | Resolution | Description |
|------|------------|-------------|
| 0x00 | 1 count/mm | Lowest sensitivity |
| 0x01 | 2 count/mm | Low sensitivity |
| 0x02 | 4 count/mm | Medium sensitivity |
| 0x03 | 8 count/mm | High sensitivity (most common) |

**Sample Rate Values** (for 0xF3 Set Sample Rate):

Common rates (Hz): 10, 20, 40, 60, 80, 100, 200

Used for both configuration and IntelliMouse detection sequences.

### Mouse Initialisation Sequence

**Standard Initialisation:**

```
1. Wait for BAT (0xAA) and device ID (0x00)
2. Detect mouse type (attempt IntelliMouse modes as described above)
3. Send 0xE8 0x03 (Set Resolution to 8 counts/mm)
4. Send 0xE6 (Set Scaling 1:1 for predictable movement)
5. Send 0xF3 0x64 (Set Sample Rate to 100 Hz)
6. Send 0xF4 (Enable Reporting)
7. Begin processing movement packets
```

**This Project's Implementation:**

See [`src/protocols/at-ps2/mouse_interface.c`](../../src/protocols/at-ps2/mouse_interface.c) for complete initialisation with type detection, configuration, and error handling.

---

## Implementation Notes

### RP2040 PIO Implementation

The converter uses RP2040's Programmable I/O (PIO) state machines for hardware-level protocol handling, providing microsecond-precision timing without CPU intervention.

**Architecture:**

```
Keyboard                    Mouse
     ↓                        ↓
PIO SM (RX)              PIO SM (RX)
PIO SM (TX)              PIO SM (TX)
     ↓                        ↓
Ring Buffer (32B)        Ring Buffer (32B)
     ↓                        ↓
Protocol Handler         Protocol Handler
     ↓                        ↓
Scancode Processor       Packet Processor
     ↓                        ↓
         USB HID Interface
```

**Key Features:**
- **Independent State Machines**: Keyboard and mouse operate completely independently
- **Non-Blocking**: PIO handles timing, main loop processes data without waiting
- **Hardware IRQ**: PIO fires interrupt when frame received, queues to ring buffer
- **Separate GPIO**: Keyboard and mouse operate on different pins (no conflicts)

**Clock Divider Calculation:**

The converter uses the `calculate_clock_divider()` function from [`src/common/lib/pio_helper.c`](../../src/common/lib/pio_helper.c) to determine the optimal PIO clock divider:

```c
// AT/PS2 timing: 30µs minimum pulse width per IBM Technical Reference
float clock_div = calculate_clock_divider(ATPS2_TIMING_CLOCK_MIN_US);
```

The function calculates the divider using 5× oversampling for reliable edge detection:

```c
// Calculation logic (from pio_helper.c):
// 1. System clock: 125 MHz (125,000 kHz)
// 2. Shortest pulse: 30µs → 33.33 kHz
// 3. Target sampling: 33.33 kHz × 5 = 166.67 kHz
// 4. Clock divider: 125,000 / 166.67 = 750
```

This results in a 6µs PIO cycle time, enabling the 96µs inhibit phase (16 cycles × 6µs) and reliable signal sampling.

**Shared PIO Program:**

Both keyboard and mouse use the same PIO program ([`interface.pio`](../../src/protocols/at-ps2/interface.pio)) loaded into separate state machines. The program handles:
- Device-to-host reception (11-bit frames: Start + 8 Data + Parity + Stop)
- Host-to-device transmission (Inhibit + Data + ACK)
- Z-150 keyboard compatibility (non-standard stop bit)
- Irregular ACK clock timing on some keyboards

**Device-to-Host Reception:**

```pio
check:
    ; Wait for incoming data, but jump to bitLoopOut if OSR has data to send
    jmp !OSRE, bitLoopOut
    jmp pin, check      ; Loop if CLOCK still high

    ; Read Start bit
    in pins, 1
    ; Wait for Clock to go High
    wait 1 pin 1

    ; Set x to 9 (to read in 8 x Data bits, 1 x Parity and 1 x Stop bit)
    set x, 9

bitLoopIn:
    ; Wait for clock signal to go low
    wait 0 pin 1 [1]
    ; Read data pin and store in ISR
    in pins, 1
    ; Wait for clock signal to go high
    wait 1 pin 1
    ; Decrement x and jump back to bitLoopIn if it's not zero
    jmp x--, bitLoopIn

    ; Jump back to check now all data read
    jmp check
```

**Host-to-Device Transmission:**

See PIO code in previous section for complete transmission sequence.

See [`interface.pio`](../../src/protocols/at-ps2/interface.pio) for the complete implementation.

### Ring Buffer Architecture

**Lock-Free SPSC (Single-Producer, Single-Consumer):**
- **Producer**: PIO IRQ handler writes received bytes
- **Consumer**: Main loop reads bytes for processing
- **Size**: 32 bytes (adequate for burst typing/movement)
- **Overflow Handling**: Oldest data discarded if full (rare—only during sustained 30+ CPS typing)

**Thread Safety:**
- No locks or mutexes (lock-free design)
- Atomic head/tail pointer updates
- Memory barriers (`__dmb()`) ensure visibility across contexts

### Signal Quality and Troubleshooting

**Common Problems:**

**Intermittent Key Presses / Missed Movement:**
- **Cause**: Poor electrical connections, loose breadboard contacts
- **Solution**: Check all connections, reseat jumper wires, verify solder joints on permanent builds

**No Communication:**
- **Cause**: Incorrect wiring, damaged level shifter, wrong GPIO pins
- **Solution**: Verify pinout with multimeter, test level shifter with logic analyzer
- **Debug**: Check that CLOCK and DATA lines idle HIGH (5V on keyboard side, 3.3V on RP2040 side)

**Parity Errors:**
- **Cause**: Electrical noise, incorrect clock timing, failing level shifter
- **Solution**: Shorter cables, shielded cables, verify clock frequency within 10-16.7 kHz
- **Debug**: Logic analyzer to capture CLOCK/DATA signals, check timing against specification

**Keys Repeat or Stick:**
- **Cause**: Missing break codes, scancode processor state machine confused
- **Solution**: Power cycle keyboard, check for hot-swap during operation

**LED Control Not Working:**
- **Cause**: Keyboard doesn't support LEDs (XT protocol), host-to-device timing incorrect
- **Solution**: Verify keyboard protocol (AT/PS2 required for LED control), check PIO TX program timing

---

## Troubleshooting

The AT/PS2 protocol is pretty well-established, so most issues tend to be hardware-related rather than protocol issues. That said, there are a few protocol-specific things worth checking if you're running into problems. For general hardware troubleshooting, see the **[Hardware Setup Guide](../getting-started/hardware-setup.md)**.

**Basic voltage checks with a multimeter:**
- Keyboard VCC: 4.75-5.25V
- Idle CLOCK/DATA (keyboard side): ~5V
- Idle CLOCK/DATA (RP2040 side): ~3.3V
- Level shifter powered: LV=3.3V, HV=5V

### Common Issues

| Symptom | Likely Cause | What to Check |
|---------|--------------|---------------|
| No response | Power issue, bad connections | Check VCC, GND, verify continuity |
| Random characters | Parity errors, noise | Shorter cables, shielded cables, check level shifter |
| Missing keypresses | Ring buffer overflow, bad connections | Improve connections, verify signal quality |
| LEDs don't work | XT protocol, TX timing wrong | Verify AT/PS2 protocol, check PIO TX program |
| Mouse not detected | Wrong connector, bad wiring | Verify pinout, check mouse power (VCC/GND) |
| Scroll wheel not working | Standard PS/2 mouse | Use IntelliMouse-compatible mouse |

---

## Related Documentation

- **[Hardware Setup](../hardware/README.md)** - Physical connections and level shifters
- **[Custom PCB](../hardware/custom-pcb.md)** - Example internal installation
- **[Keyboards](../keyboards/README.md)** - Supported AT/PS2 keyboards
- **[Scancode Set 2](../scancodes/set2.md)** - Scancode translation tables
- **[Advanced Topics](../advanced/README.md)** - System architecture and implementation

---

## References

### Official Documentation

1. **IBM Technical Reference Manual** - PC/AT - AT keyboard protocol specification
2. **IBM PS/2 Hardware Technical Reference** - PS/2 specification - Standardized connector and protocol
3. **Microsoft PS/2 Mouse Programmer's Reference** - Mouse protocol details and IntelliMouse extensions
4. **Intel 8042 Controller Datasheet** - Keyboard controller implementation reference
5. **IBM 84F9735** - PS/2 Hardware Interface Technical Reference (timing specifications)

### Implementation References

6. **[The AT Keyboard Interface (Adam Chapweske)](https://www.tayloredge.com/reference/Interface/atkeyboard.pdf)** - AT/PS2 protocol specification and timing details
7. **[TMK Keyboard Wiki - IBM PC AT Keyboard Protocol](https://github.com/tmk/tmk_keyboard/wiki/IBM-PC-AT-Keyboard-Protocol)** - Detailed protocol documentation with scancode tables and waveform analysis
8. **[KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/)** - Connector pinouts and protocol specifications (connector diagrams used in this document)

### Our Implementation

9. **[`interface.pio`](../../src/protocols/at-ps2/interface.pio)** - RP2040 PIO state machine for AT/PS2 protocol
10. **[`keyboard_interface.c`](../../src/protocols/at-ps2/keyboard_interface.c)** - Keyboard C implementation, IRQ handlers, and state machine
11. **[`mouse_interface.c`](../../src/protocols/at-ps2/mouse_interface.c)** - Mouse C implementation and packet processing
12. **[`common_interface.c`](../../src/protocols/at-ps2/common_interface.c)** - Shared protocol functions and parity lookup table
13. **[`pio_helper.c`](../../src/common/lib/pio_helper.c)** - Clock divider calculation utility

---

**Questions or stuck on something?**  
Pop into [GitHub Discussions](https://github.com/PaulW/rp2040-keyboard-converter/discussions) or [report a bug](https://github.com/PaulW/rp2040-keyboard-converter/issues) if you've found an issue.
