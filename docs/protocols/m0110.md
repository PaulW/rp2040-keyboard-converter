# Apple M0110 Protocol

**Status**: ✅ Production | **Last Updated**: 27 October 2025

The Apple M0110 keyboard protocol represents Apple's elegant approach to keyboard communication for the original Macintosh computers (1984-1986). Unlike contemporary protocols that gave keyboards control over when to send data, the M0110 protocol implements **passive polling**: the host computer maintains complete control, explicitly requesting key state whenever desired.

This host-controlled architecture made M0110 keyboards **deterministic and predictable**—critical qualities for Apple's groundbreaking graphical user interface where timing consistency mattered. The protocol's simplicity (just four commands) and MSB-first bit order (unusual for the era) demonstrate Apple's willingness to chart their own course, independent of IBM PC conventions.

---

## Table of Contents

- [Historical Context](#historical-context)
- [Protocol Overview](#protocol-overview)
- [Physical Interface](#physical-interface)
- [Communication Protocol](#communication-protocol)
- [Commands and Responses](#commands-and-responses)
- [Keyboard Operation](#keyboard-operation)
- [Implementation Notes](#implementation-notes)
- [Troubleshooting](#troubleshooting)
- [Related Documentation](#related-documentation)
- [References](#references)

---

## Historical Context

### The Macintosh Revolution

**1984 - Macintosh 128K/512K**: When Apple introduced the original Macintosh in January 1984, they revolutionized personal computing with the first mass-market graphical user interface. The M0110 keyboard was a compact design without a numeric keypad, featuring a minimalist layout that matched the Mac's design aesthetic. For users requiring numeric input, Apple offered the separate M0120 numeric keypad accessory.

The M0110 protocol reflected Apple's design philosophy: **simplicity and control**. Rather than allowing the keyboard to asynchronously interrupt the system (like XT or AT protocols), Apple engineers chose a polling architecture where the computer remained in complete control. This decision aligned with the Mac's real-time GUI requirements—predictable timing was more important than minimal CPU overhead.

**1986 - Macintosh Plus and M0110A**: The Macintosh Plus brought significant improvements: 1MB RAM, SCSI port, and enhanced keyboard support. The M0110A keyboard redesigned the layout by integrating a numeric keypad and adding dedicated cursor (arrow) keys, creating a more complete keyboard that eliminated the need for the separate M0120 accessory. Protocol compatibility remained perfect throughout this evolution.

**Evolution and Variants**:

- **M0110**: Original Macintosh 128K/512K keyboard (1984) - compact layout without numeric keypad
- **M0110A**: Enhanced keyboard for Macintosh Plus (1986) - integrated numeric keypad and added cursor keys  
- **M0120**: Separate numeric keypad accessory (sold separately) - designed to complement the M0110 which lacked integrated keypad

**Legacy**: While the ADB (Apple Desktop Bus) protocol superseded M0110 in 1987 with the Macintosh SE and II, M0110 keyboards remain cherished by enthusiasts for their tactile feel (Alps SKCM switches) and compact layout. Modern converters allow these vintage keyboards to work with contemporary computers, preserving their utility decades later.

### Design Philosophy

The M0110 protocol embodies Apple's core design principles:

1. **Host Authority**: Computer controls communication, keyboards never initiate
2. **Deterministic Timing**: No async interrupts, predictable response times
3. **Simplicity**: Four commands total (Inquiry, Instant, Model, Test)
4. **Self-Contained**: Keyboard includes all logic, no external intelligence required
5. **Robustness**: Timeout handling ensures system doesn't hang on keyboard errors

These weren't just technical choices—they reflected Apple's belief that simplicity and control create better user experiences.

---

## Protocol Overview

### Key Characteristics

The M0110 protocol differs fundamentally from interrupt-driven protocols like XT/AT/PS2:

**Passive Polling Architecture:**
- Host initiates all communication (keyboard never sends unsolicited data)
- Command-response pairs are stateless and independent
- Deterministic timing makes behavior predictable

**Comparison:**

| Feature | XT/AT/PS2 | M0110 |
|---------|-----------|-------|
| **Initiation** | Keyboard sends data when keys pressed | Host polls keyboard with Inquiry command |
| **Timing** | Asynchronous interrupts | Synchronous, host-controlled |
| **Host Load** | Must respond to interrupts immediately | Processes responses at convenience |

**MSB-First Bit Order:**

M0110 transmits the most significant bit first (bit 7 → bit 6 → ... → bit 0), unlike IBM protocols which use LSB-first. For example, byte `0x3C` transmits as bits 7, 6, 5, 4, 3, 2, 1, 0 in that order.

**Synchronous Serial Communication:**
- **CLOCK**: Bit timing (keyboard generates clock for both directions)
- **DATA**: Bit values (sampled on clock rising edge)
- **Frame**: 8 data bits, no start/stop/parity bits
- **Bidirectional**: Host and keyboard alternate as transmitter

---

## Physical Interface

### Connector and Pinout

![Mac Plus Connector Pinout](../images/connectors/kbd_connector_macplus.png)

*Image credit: [KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/conn/index.html)*

M0110 keyboards use an **RJ-10 (4P4C) connector** (often called a "telephone jack"):

**Pinout** (looking at keyboard jack):
- Pin 1: GND - Ground (0V reference)
- Pin 2: CLOCK - Serial clock line (bidirectional)
- Pin 3: DATA - Serial data line (bidirectional)
- Pin 4: VCC - +5V power from host

**Important Connector Note**:

The RJ-10 (4P4C) connector is the same as used for telephone handsets, making cables readily available. However, **pinout is NOT standard telephone**—using a telephone cable will not work and may damage equipment. Always verify pinout before connecting.

**Availability**: RJ-10 connectors common and inexpensive from electronics suppliers, but verify pinout before connecting.

### Electrical Characteristics

**Logic Levels (TTL):**

| Level | Voltage | Interpretation |
|-------|---------|----------------|
| HIGH (Logic 1) | 2.4V to 5.5V | Inactive/idle state |
| LOW (Logic 0) | 0V to 0.8V | Active/asserted state |

**Signal Configuration:**
- Type: Open-drain with external pull-ups
- Direction: Bidirectional (host and keyboard alternate)
- Idle State: Both DATA and CLOCK HIGH (~5V)
- Pull-ups: 4.7kΩ to 10kΩ on host (Macintosh logic board)

**Power Requirements:**
- Voltage: +5V ±5% (4.75V to 5.25V)
- Current: 30-100mA typical, up to 150mA during power-on self-test

**Timing Specifications:**

| Parameter | Keyboard → Host | Host → Keyboard | Notes |
|-----------|----------------|-----------------|-------|
| **Clock Period** | 330µs (~3.03 kHz) | 400µs (~2.5 kHz) | Complete bit time |
| **Clock Low** | 160µs | 180µs | CLOCK pulled LOW |
| **Clock High** | 170µs | 220µs | CLOCK released HIGH |
| **Data Setup** | 40µs | 40µs | DATA stable before CLK↑ |
| **Data Hold** | 40µs | 40µs | DATA stable after CLK↑ |
| **RTS Duration** | — | 840µs (keyboard delay) | DATA LOW before keyboard clocks |
| **Hold After TX** | — | 80µs | DATA held after final bit |

**Protocol Timeouts:**
- Response Timeout: 500ms (keyboard not responding)
- Initialization Delay: 1000ms (power-on wait)
- Model Retry Interval: 500ms (between retry attempts)

### Signal Integrity

**Cable Considerations**:

- **Maximum Length**: 2 meters recommended (longer cables degrade signals)
- **Shielding**: Not required for typical installations
- **Capacitance**: Keep cable capacitance low (< 100pF) to maintain fast edges

**Noise Immunity**:

The push-pull architecture provides good noise immunity:
- Both lines actively driven (strong signals)
- Fast rise/fall times reduce susceptibility to noise
- Synchronous clocking provides timing reference

**Recommended Protection**:

```
- Series resistors: 100Ω on DATA and CLOCK (current limiting)
- ESD protection: TVS diodes on signal lines (optional but recommended)
- Power filtering: 0.1µF ceramic + 10µF electrolytic near keyboard
- Reverse polarity protection: Diode on VCC line (prevents damage from miswiring)
```

---

## Communication Protocol

### Signal Diagrams

#### Receiving Data (Keyboard → Host)

This diagram shows how the host reads data from the keyboard. The keyboard drives the CLOCK line, and the host reads the DATA line on the rising edge of the clock signal.

```
        ___ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    CLK    \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
        ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
    DAT    \___X___X___X___X___X___X___X___/
             7   6   5   4   3   2   1   0

Host reads DATA on Rising Edge of CLOCK
Clock: LOW for 160µs, HIGH for 170µs
Total bit period: 330µs (~3.03 kHz)
```

#### Transmitting Data (Host → Keyboard)

This diagram illustrates the host sending a command to the keyboard. The transmission is initiated by the host but clocked by the keyboard. The host's data transmission is synchronized with the keyboard's clock.

```
        _______ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    CLK        \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
        ___     ___ ___ ___ ___ ___ ___ ___ ___ ___
    DAT    \___/___X___X___X___X___X___X___X___/
             *   7   6   5   4   3   2   1   0

Communication Flow (per Apple Technical Documentation):
1. Host signals ready by pulling DATA LOW
2. Keyboard detects this and begins clocking (after ~840µs internal delay)
3. Host transmits command (MSB first) while keyboard provides clock
4. Clock: LOW for 180µs, HIGH for 220µs
5. Total bit period: 400µs (~2.5 kHz)
```

**Key Points**:
- **Keyboard controls CLOCK** in both directions (keyboard→host and host→keyboard)
- **MSB-first** bit order (bit 7 transmitted first, then 6, 5, 4, 3, 2, 1, 0)
- **No parity or stop bits** - pure 8-bit transmission
- **Host samples on CLOCK rising edge** when receiving
- **Keyboard samples on CLOCK rising edge** when receiving from host

### Bit Timing and Frame Structure

Each byte consists of 8 bits transmitted MSB-first with precise timing (see timing table above).

**Frame Format:**
```
Keyboard → Host: 8 bits × 330µs = 2.64ms per byte
Host → Keyboard: 8 bits × 400µs = 3.20ms per byte
```

**Sampling Point:** CLOCK rising edge (DATA must be stable during 40µs setup/hold window)

**Example - Transmitting 0x12 (00010010 binary):**

| Bit # | Position | Value | Time |
|-------|----------|-------|------|
| 1 | Bit 7 (MSB) | 0 | 330µs |
| 2 | Bit 6 | 0 | 330µs |
| 3 | Bit 5 | 0 | 330µs |
| 4 | Bit 4 | 1 | 330µs |
| 5 | Bit 3 | 0 | 330µs |
| 6 | Bit 2 | 0 | 330µs |
| 7 | Bit 1 | 1 | 330µs |
| 8 | Bit 0 (LSB) | 0 | 330µs |
| **Total** | — | — | **2.64ms** |

### Request-to-Send (RTS) Sequence

Before transmitting a command, the host signals its intention using RTS:

**Sequence:**
1. Host pulls DATA LOW (RTS signal)
2. Keyboard detects DATA LOW
3. Keyboard waits ~840µs (internal delay)
4. Keyboard begins generating CLOCK pulses
5. Host transmits command synchronized to keyboard's CLOCK

**Timing:**
```
Host:     Pull DATA LOW → Configure pins → Wait for keyboard CLOCK
          |←→|
DATA  ────┐  └────────╳═══Command Byte═══╳────────
          └───────────┘
                      ↑
          Keyboard's 840µs delay before clocking starts
```

**Note:** The 840µs delay is the keyboard's responsibility. The host simply pulls DATA LOW and waits for the keyboard to start clocking.

**PIO Receive Implementation** (from [`keyboard_interface.pio`](../../src/protocols/m0110/keyboard_interface.pio)):

```pio
; Receiving Data (Keyboard → Host)
;
;        ___ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
;    CLK    \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
;        ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
;    DAT    \___X___X___X___X___X___X___X___/
;             7   6   5   4   3   2   1   0
;
; Host reads DATA on Rising Edge of CLOCK.
; Clock is brought LOW for 160us, and HIGH for 170us during pulses.

; Loop to receive 7 bits (MSB first), then manually read final bit
set x, 6

bitLoopIn:
    wait 1 pin 1        ; Wait for CLOCK rising edge
    in pins, 1          ; Read DATA pin (sample on rising edge)
    wait 0 pin 1        ; Wait for CLOCK falling edge
    jmp x--, bitLoopIn  ; Decrement and loop
    
    ; Read final bit
    wait 1 pin 1        ; Wait for CLOCK rising edge
    in pins, 1          ; Read last bit
```

**PIO Transmit Implementation** (from [`keyboard_interface.pio`](../../src/protocols/m0110/keyboard_interface.pio)):

```pio
bitLoopOut:
    ; Sending Data (Host → Keyboard)
    ;
    ;        _______ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    ;    CLK        \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
    ;        ___     ___ ___ ___ ___ ___ ___ ___ ___ ___
    ;    DAT    \___/___X___X___X___X___X___X___X___/
    ;             *   7   6   5   4   3   2   1   0
    ;
    ; * Host initiates by pulling DATA LOW (RTS)
    ; Keyboard detects and begins clocking (approx. 840us delay)
    ; Host needs to hold DATA (last bit) for approx 80us after rising edge

    set pins, 0         ; Pull DATA low (RTS request)
    set pindirs 1  [1]  ; Set CLK to Input, DATA to Output
    
    ; Send 8 bits, MSB first
    set x, 7
    
bitLoopOutLoop:
    wait 0 pin 1 [1]    ; Wait for keyboard CLOCK low
    out pins, 1         ; Place data bit on DATA line
    wait 1 pin 1        ; Wait for CLOCK rising edge
    jmp x--, bitLoopOutLoop
    
    nop [16]            ; Hold DATA for ~80µs (keyboard reads final bit)
    
    ; Release DATA line
    set pins, 0
    set pindirs, 0      ; Return to input mode
```

---

## Commands and Responses

The M0110 protocol defines four commands. Commands are sent by the host; keyboards respond with status codes or key events.

### Command Summary

| Command | Hex | Binary | Purpose | Response Time |
|---------|-----|--------|---------|---------------|
| **Inquiry** | 0x10 | 00010000 | Request key transitions | ~3ms |
| **Instant** | 0x14 | 00010100 | Request current key state | ~3ms |
| **Model** | 0x16 | 00010110 | Request ID + reset keyboard | ~5ms |
| **Test** | 0x36 | 00110110 | Run self-test | ~300ms |

### Response Codes

| Response | Hex | Binary | Description |
|----------|-----|--------|-------------|
| **Null** | 0x7B | 0111 1011 | No key activity |
| **Keypad** | 0x79 | 0111 1001 | External keypad detected |
| **Test Pass** | 0x7D | 0111 1101 | Self-test passed |
| **Test Fail** | 0x77 | 0111 0111 | Self-test failed |
| **Key Press** | 0x00-0x7F | 0xxx xxxx | Key make code (bit 7 = 0) |
| **Key Release** | 0x80-0xFF | 1xxx xxxx | Key break code (bit 7 = 1) |

**Model Identification Responses:**

| Response | Hex | Binary | Keyboard Model |
|----------|-----|--------|----------------|
| **M0110 (GS536)** | 0x03 | 0000 0011 | Original M0110 variant |
| **M0110 (GS624)** | 0x09 | 0000 1001 | Original M0110 variant |
| **M0110A** | 0x0B | 0000 1011 | Enhanced with arrow keys |
| **M0120 Keypad** | 0x11 | 0001 0001 | Standalone numeric keypad |
| **M0110+M0120 (GS536)** | 0x13 | 0001 0011 | M0110 + keypad |
| **M0110+M0120 (GS624)** | 0x19 | 0001 1001 | M0110 + keypad |
| **M0110A+M0120** | 0x1B | 0001 1011 | M0110A + keypad |

**Key Event Encoding:**
- Bit 7 = 0: Key pressed (make code, e.g., 0x12)
- Bit 7 = 1: Key released (break code = make | 0x80, e.g., 0x92)
- Bits 6-0: Key position (0x00 to 0x7F)

---

### Command Details

#### 0x10: Inquiry (Request Key Transitions)

Requests any key state changes since the last inquiry.

**Responses:**
- `0x7B`: Null (no key activity)
- `0x79`: Keypad detected
- `0x00-0x7F`: Key pressed
- `0x80-0xFF`: Key released

**Polling Rate:**
- Original specification: 250ms intervals
- Modern implementations: < 1ms intervals (faster polling reduces latency)

**Note:** Each Inquiry reports only one key event. Multiple inquiries required if multiple keys changed state.

#### 0x14: Instant (Request Immediate Key State)

Returns the current state of all keys (snapshot).

**Responses:**
- `0x7B`: No keys held
- `0x7D`: One or more keys pressed (followed by key codes)

**Usage:** Rarely used in practice. Apple's ROMs primarily relied on Inquiry for edge-triggered key events. Mainly useful for diagnostics.

#### 0x16: Model (Request Keyboard Identification)

Identifies keyboard model and triggers internal reset.

**Responses:** See Model Identification Responses table above (0x03, 0x09, 0x0B, 0x11, 0x13, 0x19, 0x1B)

**Side Effect:** Triggers keyboard reset (clears key buffer, resets modifiers, reinitializes key matrix)

**Usage:** Sent during initialization to identify keyboard type and ensure clean state.

#### 0x36: Test (Initiate Self-Test)

Runs keyboard's built-in diagnostic (ROM checksum, RAM test, key matrix check, timing verification).

**Responses:**
- `0x7D`: Self-test passed
- `0x77`: Self-test failed

**Duration:** 200-500ms

**Usage:** Manufacturing QC, repair diagnostics, troubleshooting. Rarely used during normal operation.

---

## Keyboard Operation

### Power-On Initialization

**Sequence:**
1. Keyboard receives +5V power from host
2. Microcontroller boots (~100-200ms)
3. Self-test runs automatically (ROM, RAM, key matrix checks)
4. Keyboard enters idle state (DATA and CLOCK HIGH)
5. Host waits 1000ms, then sends Model command (0x16)
6. Keyboard responds with model ID and resets
7. Host begins continuous Inquiry polling

**Timing:** Original Macintosh ROM required 1000ms delay. Modern implementations can use 200-500ms, but 1000ms ensures compatibility with all units.

### Normal Operation

**Continuous Polling Loop:**

Modern implementation (< 1ms per cycle):
1. Host sends Inquiry (0x10)
2. Keyboard responds: `0x7B` (no keys), `0x00-0x7F` (key press), or `0x80-0xFF` (key release)
3. Host processes response and updates HID report
4. Repeat immediately

**Cycle time:** ~7ms (RTS + command + response), effective rate ~140 Hz

**Original implementation:** 250ms polling interval (4 Hz), adequate for 1984 mechanical keyboards

### Key State Encoding

| Format | Description | Example |
|--------|-------------|---------|
| **Make Code** | Bit 7 = 0, bits 6-0 = key position | `0x12` = Key 0x12 pressed |
| **Break Code** | Bit 7 = 1, bits 6-0 = key position | `0x92` = Key 0x12 released (0x12 \| 0x80) |
| **Null Response** | `0x7B` when no keys changed | Not a valid key code |

---

## Implementation Notes

### Critical Requirements

**Hardware Timing:**
- Use PIO (RP2040) or hardware timers for microsecond-precise bit timing
- Never use software delays (`sleep_us()`, busy-wait loops)
- Implement interrupt-driven reception with ring buffer
- Buffer size: 32 bytes minimum

**Protocol Handling:**
- Keyboard generates CLOCK for both transmit and receive
- RTS: Host pulls DATA LOW, waits for keyboard to start clocking (~840µs)
- Non-blocking: Main loop checks buffer and USB readiness
- Timeout: 500ms response timeout triggers reinitialization

**Initialization:**
- Power-on delay: 1000ms before first Model command
- Model retry: 5 attempts at 500ms intervals
- State machine: UNINITIALISED → INIT_MODEL_REQUEST → INITIALISED

**Error Recovery:**
- Clear ring buffer on timeout
- Reset to UNINITIALISED state
- Automatic retry with exponential backoff

### Converter Architecture

The RP2040 converter uses three layers:

**Layer 1: PIO Hardware** ([`keyboard_interface.pio`](../../src/protocols/m0110/keyboard_interface.pio))
- Receives keyboard-generated CLOCK
- Samples DATA on CLOCK rising edge
- Transmits commands synchronized to keyboard CLK
- Triggers IRQ on complete byte

**Layer 2: IRQ Handler** ([`keyboard_input_event_handler`](../../src/protocols/m0110/keyboard_interface.c))
- Reads byte from PIO RX FIFO
- Writes to ring buffer (lock-free producer)
- Minimal processing for low latency

**Layer 3: Main Loop** ([`keyboard_interface_task`](../../src/protocols/m0110/keyboard_interface.c))
- Reads from ring buffer (consumer)
- Manages state machine
- Sends commands via PIO TX FIFO
- Handles timeouts and error recovery
- Processes scancodes → HID reports

### Implementation Example

**State Machine** (from [`keyboard_interface.c`](../../src/protocols/m0110/keyboard_interface.c)):

```c
void keyboard_interface_task(void) {
  uint32_t current_time = board_millis();
  
  switch (keyboard_state) {
    case UNINITIALISED:
      // Wait 1000ms after power-on
      if ((current_time - last_command_time) > 1000) {
        keyboard_state = INIT_MODEL_REQUEST;
        keyboard_command_handler(M0110_CMD_MODEL);
      }
      break;
      
    case INIT_MODEL_REQUEST:
      // Retry Model command every 500ms (up to 5 attempts)
      if ((current_time - last_command_time) > 500) {
        if (model_retry_count < 5) {
          keyboard_command_handler(M0110_CMD_MODEL);
          model_retry_count++;
        } else {
          keyboard_state = UNINITIALISED;  // Give up, restart
        }
      }
      break;
      
    case INITIALISED:
      // Timeout detection
      if ((current_time - last_response_time) > 500) {
        ringbuf_reset();  // Clear stale data
        keyboard_state = UNINITIALISED;
        break;
      }
      
      // Process buffered key data
      if (!ringbuf_is_empty() && tud_hid_ready()) {
        uint8_t scancode = ringbuf_get();
        process_scancode(scancode);
      }
      break;
  }
}
```

**Response Handler** (called by IRQ):

```c
static void keyboard_event_processor(uint8_t data_byte) {
  last_response_time = board_millis();
  
  switch (keyboard_state) {
    case INIT_MODEL_REQUEST:
      // Model ID received (0x03, 0x09, 0x0B, etc.)
      LOG_INFO("Model: 0x%02X\n", data_byte);
      keyboard_state = INITIALISED;
      keyboard_command_handler(M0110_CMD_INQUIRY);  // Start polling
      break;
      
    case INITIALISED:
      if (data_byte == 0x7B) {
        // Null response - send next inquiry
        keyboard_command_handler(M0110_CMD_INQUIRY);
      } else {
        // Key event - buffer for processing
        if (!ringbuf_is_full()) {
          ringbuf_put(data_byte);
        }
        keyboard_command_handler(M0110_CMD_INQUIRY);
      }
      break;
  }
}
```

### PIO Configuration

**Initialization** (from [`keyboard_interface.pio`](../../src/protocols/m0110/keyboard_interface.pio)):

```c
static inline void keyboard_interface_program_init(PIO pio, uint sm, uint offset, 
                                                     uint pin, float div) {
    // Configure pins
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, false);
    pio_gpio_init(pio, pin);      // DATA
    pio_gpio_init(pio, pin + 1);  // CLOCK
    gpio_pull_up(pin);
    gpio_pull_up(pin + 1);
    
    // Configure state machine
    pio_sm_config c = keyboard_interface_program_get_default_config(offset);
    sm_config_set_in_shift(&c, false, true, 8);   // MSB first, autopush at 8 bits
    sm_config_set_out_shift(&c, false, true, 8);  // MSB first, autopull at 8 bits
    sm_config_set_clkdiv(&c, div);
    
    // Enable IRQ on RX FIFO data
    pio_set_irq0_source_enabled(pio, pis_sm0_rx_fifo_not_empty + sm, true);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
```

**Clock Divider:** Calculated for 160µs timing with 5× oversampling (see `pio_helper.c`)

**Note:** PIO code shown earlier in Communication Protocol section provides complete receive/transmit implementation.

---

## Troubleshooting

### Diagnostic Tools

**Logic Analyzer:**
Capture DATA and CLOCK lines to verify:
- Keyboard TX: 330µs clock period (160µs low, 170µs high)
- Host TX: 400µs clock period (180µs low, 220µs high)
- RTS duration: ~840µs (DATA LOW before keyboard starts clocking)
- Data hold time: 80µs after final clock edge
- MSB-first bit order
- Setup/hold times: 40µs

**Multimeter:**
Verify voltage levels:
- VCC (Pin 4): 5.0V ±5%
- GND (Pin 3): 0V
- Idle DATA/CLOCK: ~5V (pulled HIGH)
- Active LOW: < 0.8V
- Active HIGH: > 2.4V

### Common Issues and Solutions

| Symptom | Possible Cause | Solution |
|---------|---------------|----------|
| No response | Power issue, bad connections | Check +5V on Pin 4, GND on Pin 3, verify pull-ups |
| Initialization fails | Too early, wrong pinout | Wait 1000ms after power-on, verify RJ-10 wiring |
| Garbled responses | Wrong bit order, timing | Verify MSB-first, check clock periods (330µs/400µs) |
| Missing key events | Polling too slow, buffer full | Increase polling rate, verify ring buffer not overflowing |
| Intermittent operation | Cable too long, signal quality | Use < 2m cable, check setup/hold times (40µs) |
| Wrong model ID | Incorrect response parsing | Valid IDs: 0x03, 0x09, 0x0B, 0x11, 0x13, 0x19, 0x1B |
| Timeout errors | Keyboard not responding | Implementation auto-reinitializes after 500ms timeout |

**Debug Steps:**
1. Verify power: VCC=5V, GND=0V, idle lines=~5V
2. Check initialization: 1000ms delay, Model command (0x16) sent MSB-first
3. Verify RTS sequence: DATA LOW, keyboard waits 840µs, then clocks
4. Monitor timeout: Implementation retries Model command 5× at 500ms intervals
5. Capture signals: Logic analyzer shows clock periods, bit order, timing

---

## Related Documentation

- **[Hardware Setup](../hardware/README.md)** - Physical connections and wiring
- **[Keyboards](../keyboards/README.md)** - Supported M0110 keyboards
- **[Architecture](../advanced/README.md)** - System architecture and implementation details
- **[M0110 Scancode Set](../../src/scancodes/apple-m0110/README.md)** - Complete scancode reference

---

## References

### Primary Sources

1. **Apple Technical Documentation**:
   - [Inside Macintosh Volume III (1986)](https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_III_1985.pdf) - Pages 36-40
   - Macintosh Hardware Reference (1986)
   - M0110/M0110A Service Manual

2. **Community Implementations**:
   - [TMK Keyboard Firmware - M0110 Protocol](https://github.com/tmk/tmk_keyboard/blob/master/tmk_core/protocol/m0110.c)
   - [TMK M0110 Protocol Wiki](https://github.com/tmk/tmk_keyboard/wiki/Apple-M0110-Keyboard-Protocol)

### Implementation References

3. **[`keyboard_interface.pio`](../../src/protocols/apple-m0110/keyboard_interface.pio)** - RP2040 PIO state machine for M0110 protocol
4. **[`keyboard_interface.c`](../../src/protocols/apple-m0110/keyboard_interface.c)** - C implementation, state machine, and command handling
5. **[`keyboard_interface.h`](../../src/protocols/apple-m0110/keyboard_interface.h)** - Protocol constants and definitions
6. **[M0110 Scancode Set](../../src/scancodes/apple-m0110/README.md)** - Complete scancode reference
7. **[Architecture](../advanced/README.md)** - System architecture details

---

**Status**: This protocol is fully implemented and tested. The converter reliably handles MSB-first transmission, RTS signaling, command-response transactions, and timeout recovery, providing complete compatibility with M0110, M0110A, and M0110B keyboards. Modern optimizations (< 1ms polling vs original 250ms) deliver responsive typing while maintaining protocol integrity.

