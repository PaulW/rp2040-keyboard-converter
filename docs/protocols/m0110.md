# Apple M0110 Protocol

The M0110 keyboard protocol is Apple's keyboard communication system for the original Macintosh computers. The protocol uses passive polling architecture where the Mac controls all communication, polling the keyboard when it needs to check for key events.

The protocol uses just four commands total and transmits data MSB-first.

**Implementation Status**: Protocol implementation's done as far as I can test it currently. I'm still repairing and refurbishing the M0110A keyboard I've got, so proper hardware validation's limited for now. The scancode translation layer's waiting on that being finished.

---

## Historical Context

### Protocol Design

The M0110 protocol uses host-controlled polling. The computer initiates all communication by polling the keyboard for key events. This differs from interrupt-driven protocols where the keyboard initiates transmission when keys are pressed.

The original M0110 keyboard does not include a numeric keypad. A separate M0120 numeric keypad was available that connected in series between the keyboard and computer.

The M0110A keyboard integrated a numeric keypad and added arrow keys. The protocol specification remained unchanged from the M0110.

Apple Desktop Bus (ADB) later replaced the M0110 protocol, providing support for multiple devices on a single bus. This converter enables M0110 keyboards to connect to modern USB-based systems.

### Protocol Characteristics

The M0110 protocol has some distinct characteristics:

1. **Host-Controlled**: The computer initiates all communication, keyboards never send unsolicited data
2. **Deterministic Timing**: No async interrupts, response times are completely predictable
3. **Simple Command Set**: Four commands total (Inquiry, Instant, Model, Test)
4. **Self-Contained**: Keyboard handles all its own logic internally
5. **Timeout Handling**: If the keyboard doesn't respond, the system can recover without hanging

---

## Protocol Overview

### Key Characteristics

The M0110 protocol differs from interrupt-driven protocols such as XT, AT, and PS/2:

**Passive Polling Architecture:**
- Host initiates everything (keyboard never sends unsolicited data)
- Each command-response pair is independent and stateless
- Deterministic timing means completely predictable behaviour

**Quick Comparison:**

| Feature | XT/AT/PS2 | M0110 |
|---------|-----------|-------|
| **Who Starts** | Keyboard interrupts when keys pressed | Host asks keyboard with Inquiry command |
| **Timing** | Asynchronous interrupts | Synchronous, host-controlled |
| **Host Workload** | Must respond to interrupts immediately | Processes responses when convenient |

**MSB-First Bit Order:**

M0110 transmits the most significant bit first (bit 7 → bit 6 → ... → bit 0), which is the opposite of IBM protocols that use LSB-first. So byte `0x3C` transmits as bits 7, 6, 5, 4, 3, 2, 1, 0 in that order.

**Synchronous Serial Communication:**
- **CLOCK**: Bit timing (keyboard generates clock for both directions)
- **DATA**: Bit values (sampled on clock rising edge)
- **Frame**: 8 data bits, no start/stop/parity bits
- **Bidirectional**: Host and keyboard take turns transmitting

---

## Physical Interface

### Connector and Pinout

![Mac Plus Connector Pinout](../images/connectors/kbd_connector_macplus.png)

*Image credit: [KbdBabel Vintage Keyboard Documentation](http://kbdbabel.org/conn/index.html)*

M0110 keyboards use an **RJ-10 (4P4C) connector** (often called a "telephone jack"):

**Pinout** (looking at keyboard jack):
- Pin 1: GND - Ground (0V reference)
- Pin 2: CLOCK - Serial clock line (bidirectional)
- Pin 3: DATA - Serial data line (bidirectional)
- Pin 4: VCC - +5V power from host

**Important Connector Warning**:

The RJ-10 (4P4C) connector looks exactly like what you'd find on an old telephone handset, which means cables are easy to find. However, **the pinout is NOT standard telephone wiring**! Using a regular phone cable won't work and could actually damage your keyboard or computer. Always verify the pinout before connecting anything.

**Availability**: RJ-10 connectors are available from electronics suppliers. Verify the pinout before connecting.

### Electrical Characteristics

**Logic Levels (TTL):**

| Level | Voltage | Interpretation |
|-------|---------|----------------|
| HIGH (Logic 1) | 2.4V to 5.5V | Inactive/idle state |
| LOW (Logic 0) | 0V to 0.8V | Active/asserted state |

**Signal Configuration:**
- Type: Open-drain with external pull-ups
- Direction: Bidirectional (host and keyboard alternate)
- Idle State: Both DATA and CLOCK HIGH (~5V)
- Pull-ups: 4.7kΩ to 10kΩ on host (Macintosh logic board)

**Power Requirements:**
- Voltage: +5V ±5% (4.75V to 5.25V)
- Current: 30-100mA typical, up to 150mA during power-on self-test

**Timing Specifications:**

| Parameter | Keyboard → Host | Host → Keyboard | Notes |
|-----------|----------------|-----------------|-------|
| **Clock Period** | 330µs (~3.03 kHz) | 400µs (~2.5 kHz) | Complete bit time |
| **Clock Low** | 160µs | 180µs | CLOCK pulled LOW |
| **Clock High** | 170µs | 220µs | CLOCK released HIGH |
| **Data Setup** | 40µs | 40µs | DATA stable before CLOCK↑ |
| **Data Hold** | 40µs | 40µs | DATA stable after CLOCK↑ |
| **RTS Duration** | — | 840µs (keyboard delay) | DATA LOW before keyboard clocks |
| **Hold After TX** | — | 80µs | DATA held after final bit |

**Protocol Timeouts:**
- Response Timeout: 500ms (keyboard not responding)
- Initialisation Delay: 1000ms (power-on wait)
- Model Retry Interval: 500ms (between retry attempts)

### Signal Integrity

**Cable Considerations**:

- **Maximum Length**: 2 meters recommended (longer cables degrade signals)
- **Shielding**: Not required for typical installations
- **Capacitance**: Keep cable capacitance low (< 100pF) to maintain fast edges

**Noise Immunity**:

The push-pull architecture provides good noise immunity:
- Both lines actively driven (strong signals)
- Fast rise/fall times reduce susceptibility to noise
- Synchronous clocking provides timing reference

**Recommended Protection**:

```
- Series resistors: 100Ω on DATA and CLOCK (current limiting)
- ESD protection: TVS diodes on signal lines (optional but recommended)
- Power filtering: 0.1µF ceramic + 10µF electrolytic near keyboard
- Reverse polarity protection: Diode on VCC line (prevents damage from miswiring)
```

---

## Communication Protocol

### Signal Diagrams

#### Receiving Data (Keyboard → Host)

The host reads data from the keyboard. The keyboard drives the CLOCK line, and the host reads the DATA line on the rising edge of the clock signal.

```
          ___ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    CLOCK    \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
          ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
    DATA     \___X___X___X___X___X___X___X___/
               7   6   5   4   3   2   1   0

Host reads DATA on Rising Edge of CLOCK
Clock: LOW for 160µs, HIGH for 170µs
Total bit period: 330µs (~3.03 kHz)
```

#### Transmitting Data (Host → Keyboard)

The host sends a command to the keyboard. The transmission is initiated by the host but clocked by the keyboard. The host's data transmission is synchronised with the keyboard's clock.

```
          _______ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    CLOCK        \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
          ___     ___ ___ ___ ___ ___ ___ ___ ___ ___
    DATA     \___/___X___X___X___X___X___X___X___/
               *   7   6   5   4   3   2   1   0

Communication Flow (per Apple Technical Documentation):
1. Host signals ready by pulling DATA LOW
2. Keyboard detects this and begins clocking (after ~840µs internal delay)
3. Host transmits command (MSB first) whilst keyboard provides clock
4. Clock: LOW for 180µs, HIGH for 220µs
5. Total bit period: 400µs (~2.5 kHz)
```

**Key Points**:
- **Keyboard controls CLOCK** in both directions (keyboard→host and host→keyboard)
- **MSB-first** bit order (bit 7 transmitted first, then 6, 5, 4, 3, 2, 1, 0)
- **No parity or stop bits** - pure 8-bit transmission
- **Host samples on CLOCK rising edge** when receiving
- **Keyboard samples on CLOCK rising edge** when receiving from host

### Bit Timing and Frame Structure

Each byte consists of 8 bits transmitted MSB-first with precise timing (see timing table above).

**Frame Format:**
```
Keyboard → Host: 8 bits × 330µs = 2.64ms per byte
Host → Keyboard: 8 bits × 400µs = 3.20ms per byte
```

**Sampling Point:** CLOCK rising edge (DATA must be stable during 40µs setup/hold window)

**Example - Transmitting 0x12 (00010010 binary):**

| Bit # | Position | Value | Time |
|-------|----------|-------|------|
| 1 | Bit 7 (MSB) | 0 | 330µs |
| 2 | Bit 6 | 0 | 330µs |
| 3 | Bit 5 | 0 | 330µs |
| 4 | Bit 4 | 1 | 330µs |
| 5 | Bit 3 | 0 | 330µs |
| 6 | Bit 2 | 0 | 330µs |
| 7 | Bit 1 | 1 | 330µs |
| 8 | Bit 0 (LSB) | 0 | 330µs |
| **Total** | — | — | **2.64ms** |

### Request-to-Send (RTS) Sequence

Before transmitting a command, the host needs to signal the keyboard that it wants to send something.

**Sequence:**
1. Host pulls DATA LOW (RTS signal)
2. Keyboard detects DATA LOW
3. Keyboard waits ~840µs (internal delay)
4. Keyboard begins generating CLOCK pulses
5. Host transmits command synchronised to keyboard's CLOCK

**Timing:**
```
Host:     Pull DATA LOW → Configure pins → Wait for keyboard CLOCK
          |←→|
DATA  ────┐  └────────╳═══Command Byte═══╳────────
          └───────────┘
                      ↑
          Keyboard's 840µs delay before clocking starts
```

The 840µs delay is the keyboard's responsibility. The host simply pulls DATA LOW and waits for the keyboard to start clocking.

**PIO Receive Implementation** (from [`keyboard_interface.pio`](../../src/protocols/apple-m0110/keyboard_interface.pio)):

```pio
; Receiving Data (Keyboard → Host)
;
;          ___ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
;    CLOCK    \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
;          ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
;    DATA     \___X___X___X___X___X___X___X___/
;               7   6   5   4   3   2   1   0
;
; Host reads DATA on Rising Edge of CLOCK.
; Clock is brought LOW for 160us, and HIGH for 170us during pulses.

; Loop to receive 7 bits (MSB first), then manually read final bit
set x, 6

bitLoopIn:
    wait 1 pin 1        ; Wait for CLOCK rising edge
    in pins, 1          ; Read DATA pin (sample on rising edge)
    wait 0 pin 1        ; Wait for CLOCK falling edge
    jmp x--, bitLoopIn  ; Decrement and loop
    
    ; Read final bit
    wait 1 pin 1        ; Wait for CLOCK rising edge
    in pins, 1          ; Read last bit
```

**PIO Transmit Implementation** (from [`keyboard_interface.pio`](../../src/protocols/apple-m0110/keyboard_interface.pio)):

```pio
bitLoopOut:
    ; Sending Data (Host → Keyboard)
    ;
    ;          _______ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    ;    CLOCK        \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
    ;          ___     ___ ___ ___ ___ ___ ___ ___ ___ ___
    ;    DATA     \___/___X___X___X___X___X___X___X___/
    ;               *   7   6   5   4   3   2   1   0
    ;
    ; * Host initiates by pulling DATA LOW (RTS)
    ; Keyboard detects and begins clocking (approx. 840us delay)
    ; Host needs to hold DATA (last bit) for approx 80us after rising edge

    set pins, 0         ; Pull DATA low (RTS request)
    set pindirs 1  [1]  ; Set CLOCK to Input, DATA to Output
    
    ; Send 8 bits, MSB first
    set x, 7
    
bitLoopOutLoop:
    wait 0 pin 1 [1]    ; Wait for keyboard CLOCK low
    out pins, 1         ; Place data bit on DATA line
    wait 1 pin 1        ; Wait for CLOCK rising edge
    jmp x--, bitLoopOutLoop
    
    nop [16]            ; Hold DATA for ~80µs (keyboard reads final bit)
    
    ; Release DATA line
    set pins, 0
    set pindirs, 0      ; Return to input mode
```

---

## Commands and Responses

The M0110 protocol defines four commands. Commands are sent by the host; keyboards respond with status codes or key events.

### Command Summary

| Command | Hex | Binary | Purpose |
|---------|-----|--------|---------|
| **Inquiry** | 0x10 | 00010000 | Ask for key state changes |
| **Instant** | 0x14 | 00010100 | Get current key state snapshot |
| **Model** | 0x16 | 00010110 | Get keyboard model ID (also resets it) |
| **Test** | 0x36 | 00110110 | Run self-diagnostic |

### Response Codes

| Response | Hex | Binary | Description |
|----------|-----|--------|-------------|
| **Null** | 0x7B | 0111 1011 | No key activity |
| **Keypad** | 0x79 | 0111 1001 | External keypad detected |
| **Test Pass** | 0x7D | 0111 1101 | Self-test passed |
| **Test Fail** | 0x77 | 0111 0111 | Self-test failed |
| **Key Press** | 0x00-0x7F | 0xxx xxxx | Key make code (bit 7 = 0) |
| **Key Release** | 0x80-0xFF | 1xxx xxxx | Key break code (bit 7 = 1) |

**Model Identification Responses:**

| Response | Hex | Binary | Keyboard Model |
|----------|-----|--------|----------------|
| **M0110 (GS536)** | 0x03 | 0000 0011 | Original M0110 variant |
| **M0110 (GS624)** | 0x09 | 0000 1001 | Original M0110 variant |
| **M0110A** | 0x0B | 0000 1011 | Enhanced with arrow keys |
| **M0120 Keypad** | 0x11 | 0001 0001 | Standalone numeric keypad |
| **M0110+M0120 (GS536)** | 0x13 | 0001 0011 | M0110 + keypad |
| **M0110+M0120 (GS624)** | 0x19 | 0001 1001 | M0110 + keypad |
| **M0110A+M0120** | 0x1B | 0001 1011 | M0110A + keypad |

**Key Event Encoding:**
- Bit 7 = 0: Key pressed (make code, e.g., 0x12)
- Bit 7 = 1: Key released (break code = make | 0x80, e.g., 0x92)
- Bits 6-0: Key position (0x00 to 0x7F)

---

### Command Details

#### 0x10: Inquiry (Ask for Key Changes)

Asks the keyboard if any keys changed state since the last inquiry.

**Responses:**
- `0x7B`: Null (nothing happening)
- `0x79`: Keypad detected
- `0x00-0x7F`: Key pressed
- `0x80-0xFF`: Key released

**Polling Rate:**
- Original Mac spec: 250ms intervals (from Apple documentation)
- Modern implementations: < 1ms intervals (much faster, lower latency)

**Important:** Each Inquiry only reports one key event. If multiple keys changed, you need multiple inquiries.

#### 0x14: Instant (Get Current Key State)

Gets a snapshot of all currently pressed keys.

**Responses:**
- `0x7B`: Nothing pressed
- `0x7D`: One or more keys currently held (followed by key codes)

**Usage:** Rarely used in practice! Apple's ROMs mainly used Inquiry for detecting key presses and releases. This is mostly useful for diagnostics.

#### 0x16: Model (Get Keyboard ID)

Asks for the keyboard model number and triggers an internal reset.

**Responses:** See Model Identification Responses table above (0x03, 0x09, 0x0B, 0x11, 0x13, 0x19, 0x1B)

**Side Effect:** Resets the keyboard (clears key buffer, resets modifiers, reinitialises everything)

**Usage:** Sent during startup to figure out what keyboard model is connected and get a clean slate.

#### 0x36: Test (Run Self-Diagnostic)

Runs the keyboard's built-in diagnostic tests (ROM checksum, RAM test, key matrix check, timing verification).

**Responses:**
- `0x7D`: Self-test passed
- `0x77`: Self-test failed

**Usage:** Manufacturing testing, repair diagnostics, troubleshooting. Not used during normal typing!

---

## Keyboard Operation

### Power-On Initialisation

**What happens when you power it up:**
1. Keyboard gets +5V from the host
2. Microcontroller boots up (~100-200ms)
3. Self-test runs automatically (checks ROM, RAM, key matrix)
4. Keyboard enters idle state (DATA and CLOCK HIGH)
5. Host waits 1000ms, then sends Model command (0x16)
6. Keyboard responds with its model ID and resets itself
7. Host starts continuous Inquiry polling

**Timing Note:** The original Macintosh ROM required the full 1000ms delay (from Apple technical documentation). Modern implementations can use shorter delays, but 1000ms ensures compatibility with all keyboards.

### Normal Operation

**The Continuous Polling Loop:**

Modern implementation (< 1ms per cycle):
1. Host sends Inquiry (0x10)
2. Keyboard responds: `0x7B` (nothing), `0x00-0x7F` (key pressed), or `0x80-0xFF` (key released)
3. Host processes the response and updates the HID report
4. Repeat immediately

**Original Mac implementation:** 250ms polling interval (from Apple technical documentation)

### Key State Encoding

| Format | Description | Example |
|--------|-------------|---------|
| **Make Code** | Bit 7 = 0, bits 6-0 = key position | `0x12` = Key 0x12 pressed |
| **Break Code** | Bit 7 = 1, bits 6-0 = key position | `0x92` = Key 0x12 released (0x12 \| 0x80) |
| **Null Response** | `0x7B` when no keys changed | Not a valid key code |

---

## Implementation Notes

### Critical Requirements

**Protocol Handling:**
- The keyboard generates CLOCK for both transmit and receive (always!)
- RTS sequence: Host pulls DATA LOW, then waits for keyboard to start clocking (~840µs)
- Non-blocking operation: Main loop checks buffer and USB readiness
- Timeout: 500ms response timeout triggers reinitialisation

**Initialisation:**
- Power-on delay: Wait 1000ms before sending first Model command
- Model retry: Try up to 5 times at 500ms intervals
- State machine: UNINITIALISED → INIT_MODEL_REQUEST → INITIALISED

**Error Recovery:**
- Clear the ring buffer on timeout
- Reset back to UNINITIALISED state
- Automatic retry with exponential backoff

### Converter Architecture

The RP2040 converter uses three layers:

**Layer 1: PIO Hardware** ([`keyboard_interface.pio`](../../src/protocols/apple-m0110/keyboard_interface.pio))
- Receives keyboard-generated CLOCK
- Samples DATA on CLOCK rising edge
- Transmits commands synchronised to keyboard CLOCK
- Triggers IRQ on complete byte

**Layer 2: IRQ Handler** ([`keyboard_input_event_handler`](../../src/protocols/apple-m0110/keyboard_interface.c))
- Reads byte from PIO RX FIFO
- Writes to ring buffer (lock-free producer)
- Minimal processing for low latency

**Layer 3: Main Loop** ([`keyboard_interface_task`](../../src/protocols/apple-m0110/keyboard_interface.c))
- Reads from ring buffer (consumer)
- Manages state machine
- Sends commands via PIO TX FIFO
- Handles timeouts and error recovery
- Processes scancodes → HID reports

### Implementation Example

**State Machine** (from [`keyboard_interface.c`](../../src/protocols/apple-m0110/keyboard_interface.c)):

```c
void keyboard_interface_task(void) {
  uint32_t current_time = board_millis();
  
  switch (keyboard_state) {
    case UNINITIALISED:
      // Wait 1000ms after power-on
      if ((current_time - last_command_time) > 1000) {
        keyboard_state = INIT_MODEL_REQUEST;
        keyboard_command_handler(M0110_CMD_MODEL);
      }
      break;
      
    case INIT_MODEL_REQUEST:
      // Retry Model command every 500ms (up to 5 attempts)
      if ((current_time - last_command_time) > 500) {
        if (model_retry_count < 5) {
          keyboard_command_handler(M0110_CMD_MODEL);
          model_retry_count++;
        } else {
          keyboard_state = UNINITIALISED;  // Give up, restart
        }
      }
      break;
      
    case INITIALISED:
      // Timeout detection
      if ((current_time - last_response_time) > 500) {
        ringbuf_reset();  // Clear stale data
        keyboard_state = UNINITIALISED;
        break;
      }
      
      // Process buffered key data
      if (!ringbuf_is_empty() && tud_hid_ready()) {
        uint8_t scancode = ringbuf_get();
        process_scancode(scancode);
      }
      break;
  }
}
```

**Response Handler** (called by IRQ):

```c
static void keyboard_event_processor(uint8_t data_byte) {
  last_response_time = board_millis();
  
  switch (keyboard_state) {
    case INIT_MODEL_REQUEST:
      // Model ID received (0x03, 0x09, 0x0B, etc.)
      LOG_INFO("Model: 0x%02X\n", data_byte);
      keyboard_state = INITIALISED;
      keyboard_command_handler(M0110_CMD_INQUIRY);  // Start polling
      break;
      
    case INITIALISED:
      if (data_byte == 0x7B) {
        // Null response - send next inquiry
        keyboard_command_handler(M0110_CMD_INQUIRY);
      } else {
        // Key event - buffer for processing
        if (!ringbuf_is_full()) {
          ringbuf_put(data_byte);
        }
        keyboard_command_handler(M0110_CMD_INQUIRY);
      }
      break;
  }
}
```

### PIO Configuration

**Initialisation** (from [`keyboard_interface.pio`](../../src/protocols/apple-m0110/keyboard_interface.pio)):

```c
static inline void keyboard_interface_program_init(PIO pio, uint sm, uint offset, 
                                                     uint pin, float div) {
    // Configure pins
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, false);
    pio_gpio_init(pio, pin);      // DATA
    pio_gpio_init(pio, pin + 1);  // CLOCK
    gpio_pull_up(pin);
    gpio_pull_up(pin + 1);
    
    // Configure state machine
    pio_sm_config c = keyboard_interface_program_get_default_config(offset);
    sm_config_set_in_shift(&c, false, true, 8);   // MSB first, autopush at 8 bits
    sm_config_set_out_shift(&c, false, true, 8);  // MSB first, autopull at 8 bits
    sm_config_set_clkdiv(&c, div);
    
    // Enable IRQ on RX FIFO data
    pio_set_irq0_source_enabled(pio, pis_sm0_rx_fifo_not_empty + sm, true);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
```

**Clock Divider:** Calculated for 160µs timing with 5× oversampling (see [`pio_helper.c`](../../src/common/lib/pio_helper.c))

**Note:** PIO code shown earlier in Communication Protocol section provides complete receive/transmit implementation.

---

## Troubleshooting

The M0110 protocol's MSB-first transmission and RTS signaling differs from other keyboard protocols. Timing and bit order are common sources of issues. For general hardware setup issues, check the **[Hardware Setup Guide](../getting-started/hardware-setup.md)**.

**Basic voltage checks with a multimeter:**
- VCC (Pin 4): 5.0V ±5%
- GND (Pin 3): 0V
- Idle DATA/CLOCK: ~5V (pulled HIGH)

### Common Issues

| Symptom | Likely Cause | What to Check |
|---------|--------------|---------------|
| No response | Power issue, bad connections | Check +5V on Pin 4, GND on Pin 3, verify pull-ups |
| Initialisation fails | Too early, wrong pinout | Wait 1000ms after power-on, verify RJ-10 wiring |
| Garbled responses | Wrong bit order, timing | Verify MSB-first, check clock periods (330µs/400µs) |
| Missing key events | Polling too slow, buffer full | Increase polling rate, verify ring buffer not overflowing |
| Intermittent operation | Cable too long, signal quality | Use < 2m cable, check setup/hold times (40µs) |
| Wrong model ID | Incorrect response parsing | Valid IDs: 0x03, 0x09, 0x0B, 0x11, 0x13, 0x19, 0x1B |
| Timeout errors | Keyboard not responding | Implementation auto-reinitialises after 500ms timeout |

**Debug Steps:**
1. Verify power: VCC=5V, GND=0V, idle lines=~5V
2. Check initialisation: 1000ms delay, Model command (0x16) sent MSB-first
3. Verify RTS sequence: DATA LOW, keyboard waits 840µs, then clocks
4. Monitor timeout: Implementation retries Model command 5× at 500ms intervals

---

## Related Documentation

- **[Hardware Setup](../hardware/README.md)** - Physical connections and wiring
- **[Keyboards](../keyboards/README.md)** - Supported M0110 keyboards
- **[Scancode Sets](../scancodes/README.md)** - M0110 scancode translation and processor documentation

---

## References

### Primary Sources

1. **Apple Technical Documentation**:
   - [Inside Macintosh Volume III (1986)](https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_III_1985.pdf) - Pages 36-40
   - [Macintosh Plus Hardware Information](http://www.mac.linux-m68k.org/devel/plushw.php.html) - Keyboard Communication Protocol section

2. **Community Implementations**:
   - [TMK Keyboard Firmware - M0110 Protocol](https://github.com/tmk/tmk_keyboard/blob/master/tmk_core/protocol/m0110.c)
   - [TMK M0110 Protocol Wiki](https://github.com/tmk/tmk_keyboard/wiki/Apple-M0110-Keyboard-Protocol)

### Implementation References

3. **[`keyboard_interface.pio`](../../src/protocols/apple-m0110/keyboard_interface.pio)** - RP2040 PIO state machine for M0110 protocol
4. **[`keyboard_interface.c`](../../src/protocols/apple-m0110/keyboard_interface.c)** - C implementation, state machine, and command handling
5. **[`keyboard_interface.h`](../../src/protocols/apple-m0110/keyboard_interface.h)** - Protocol constants and definitions
6. **[Scancode Sets](../scancodes/README.md)** - M0110 scancode translation and processor documentation
7. **[Architecture](../advanced/README.md)** - System architecture details

---

**Questions or stuck on something?**  
Pop into [GitHub Discussions](https://github.com/PaulW/rp2040-keyboard-converter/discussions) or [report a bug](https://github.com/PaulW/rp2040-keyboard-converter/issues) if you've found an issue.


