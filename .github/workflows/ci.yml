name: CI Build and Lint

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  lint:
    name: Architecture Lint Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for complete git ls-files check
          submodules: true  # Include submodules for future-proofing

      - name: Run lint script
        run: |
          chmod +x tools/lint.sh
          ./tools/lint.sh --strict

      - name: Check for docs-internal files (defensive)
        run: |
          if git ls-files | grep -q "^docs-internal/"; then
            echo "ERROR: docs-internal/ files found in repository!"
            echo "These files should NEVER be committed."
            git ls-files | grep "^docs-internal/"
            exit 1
          fi
          echo "✓ No docs-internal/ files in repository"

      - name: Check for docs-internal references in commit messages
        if: github.event_name == 'pull_request'
        run: |
          # Get all commit messages in the PR
          COMMITS=$(git log origin/${{ github.base_ref }}..${{ github.sha }} --pretty=format:"%s %b")

          if echo "$COMMITS" | grep -qi "docs-internal"; then
            echo "ERROR: Commit message(s) reference 'docs-internal/'!"
            echo "Commit messages are PUBLIC documentation."
            echo ""
            echo "Offending commits:"
            git log origin/${{ github.base_ref }}..${{ github.sha }} --pretty=format:"%h %s" | grep -i "docs-internal" || true
            exit 1
          fi
          echo "✓ No docs-internal references in commit messages"

  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Load environment variables
        run: |
          # Load PICO_SDK_VERSION from .env file
          if [ -f .env ]; then
            export $(grep -v '^#' .env | xargs)
            echo "PICO_SDK_VERSION=${PICO_SDK_VERSION}" >> $GITHUB_ENV
          else
            echo "ERROR: .env file not found"
            exit 1
          fi

      - name: Build and export Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            PICO_SDK_VERSION=${{ env.PICO_SDK_VERSION }}
          tags: tardis-io/rp2040-kbd-converter:latest
          outputs: type=docker,dest=/tmp/rp2040-builder.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/rp2040-builder.tar
          retention-days: 1

  build-matrix:
    name: Build Configuration Matrix
    runs-on: ubuntu-latest
    needs: docker-build
    timeout-minutes: 10  # Reduced from 20 since Docker build is cached
    strategy:
      fail-fast: false
      matrix:
        config:
          - name: "IBM Model M Enhanced (AT/PS2 Protocol)"
            keyboard: "modelm/enhanced"
            mouse: ""
          - name: "Cherry G80-1104H (XT Protocol)"
            keyboard: "cherry/G80-1104H"
            mouse: ""
          - name: "Apple M0110A (Apple M0110 Protocol)"
            keyboard: "apple/m0110a"
            mouse: ""
          - name: "Amiga 500 (CBM Amiga Protocol)"
            keyboard: "amiga/a500"
            mouse: ""
          - name: "Model M + AT/PS2 Mouse"
            keyboard: "modelm/enhanced"
            mouse: "at-ps2"
          - name: "Cherry G80-1104H + AT/PS2 Mouse"
            keyboard: "cherry/G80-1104H"
            mouse: "at-ps2"
          - name: "AT/PS2 Mouse only"
            keyboard: ""
            mouse: "at-ps2"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: |
          docker load --input /tmp/rp2040-builder.tar
          echo "Verifying loaded image:"
          docker images | grep tardis-io/rp2040-kbd-converter

      - name: Build firmware - ${{ matrix.config.name }}
        timeout-minutes: 5  # Firmware build should complete within 5 minutes
        env:
          KEYBOARD: ${{ matrix.config.keyboard }}
          MOUSE: ${{ matrix.config.mouse }}
        run: |
          if [ -n "$KEYBOARD" ] && [ -n "$MOUSE" ]; then
            docker compose run --rm -e KEYBOARD="$KEYBOARD" -e MOUSE="$MOUSE" builder
          elif [ -n "$KEYBOARD" ]; then
            docker compose run --rm -e KEYBOARD="$KEYBOARD" builder
          elif [ -n "$MOUSE" ]; then
            docker compose run --rm -e MOUSE="$MOUSE" builder
          else
            echo "ERROR: Neither KEYBOARD nor MOUSE set"
            exit 1
          fi

      - name: Check build artifacts
        run: |
          if [ ! -f build/rp2040-converter.uf2 ]; then
            echo "ERROR: Build failed - rp2040-converter.uf2 not found"
            exit 1
          fi
          echo "✓ Build successful"
          ls -lh build/rp2040-converter.*

      - name: Prepare artifact name
        id: artifact-name
        run: |
          # Sanitize keyboard and mouse names for artifact naming (replace / with -)
          KEYBOARD_SAFE=$(echo "${{ matrix.config.keyboard }}" | tr '/' '-')
          MOUSE_SAFE=$(echo "${{ matrix.config.mouse }}" | tr '/' '-')

          # Create artifact name
          if [ -n "$KEYBOARD_SAFE" ] && [ -n "$MOUSE_SAFE" ]; then
            ARTIFACT_NAME="firmware-${KEYBOARD_SAFE}-${MOUSE_SAFE}"
          elif [ -n "$KEYBOARD_SAFE" ]; then
            ARTIFACT_NAME="firmware-${KEYBOARD_SAFE}"
          elif [ -n "$MOUSE_SAFE" ]; then
            ARTIFACT_NAME="firmware-mouse-${MOUSE_SAFE}"
          else
            ARTIFACT_NAME="firmware-unknown"
          fi

          echo "artifact_name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "Artifact name: ${ARTIFACT_NAME}"

      - name: Upload firmware artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact-name.outputs.artifact_name }}
          path: |
            build/rp2040-converter.uf2
            build/rp2040-converter.elf
          retention-days: 30
          if-no-files-found: error

  memory-check:
    name: Memory Usage Guard
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Add job-level timeout
    needs: [build-matrix]

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Install ARM toolchain
        timeout-minutes: 5  # Explicit timeout for apt operations
        run: |
          # Retry logic for apt-get to handle transient network issues
          MAX_RETRIES=3
          RETRY_DELAY=10

          for i in $(seq 1 "$MAX_RETRIES"); do
            echo "Attempt $i of $MAX_RETRIES: Installing ARM toolchain..."

            if sudo apt-get update && \
               sudo apt-get install -y --no-install-recommends gcc-arm-none-eabi binutils-arm-none-eabi; then
              echo "✓ ARM toolchain installed successfully"
              exit 0
            fi

            if [ "$i" -lt "$MAX_RETRIES" ]; then
              echo "⚠ Installation failed, retrying in ${RETRY_DELAY}s..."
              sleep "$RETRY_DELAY"
            fi
          done

          echo "❌ Failed to install ARM toolchain after $MAX_RETRIES attempts"
          exit 1

      - name: Check memory limits
        run: |
          # Memory limits (bytes)
          MAX_FLASH=235520  # ~230KB (leaving margin below 256KB)
          MAX_RAM=153600    # ~150KB (leaving margin below 264KB)

          echo "Memory Usage Check (Limits: Flash < 230KB, RAM < 150KB)"
          echo "=========================================="

          FAILED=0
          CHECKED=0

          # Iterate through all directories (defensive - handle any artifact naming)
          for artifact_dir in */; do
            # Skip if not a directory or if it doesn't look like a firmware artifact
            if [ ! -d "$artifact_dir" ]; then
              continue
            fi

            # Remove trailing slash
            artifact_dir="${artifact_dir%/}"

            # Look for ELF file (handle variations in naming)
            ELF_FILE=$(find "$artifact_dir" -name "*.elf" -type f | head -n 1)

            if [ -n "$ELF_FILE" ] && [ -f "$ELF_FILE" ]; then
              CONFIG=$(basename "$artifact_dir")
              echo ""
              echo "Configuration: $CONFIG"

              # Use arm-none-eabi-size to get section sizes
              SIZE_OUTPUT=$(arm-none-eabi-size "$ELF_FILE")

              # Parse output: "text    data     bss     dec     hex filename"
              # Flash usage = text + data
              # RAM usage = data + bss
              TEXT=$(echo "$SIZE_OUTPUT" | awk 'NR==2 {print $1}')
              DATA=$(echo "$SIZE_OUTPUT" | awk 'NR==2 {print $2}')
              BSS=$(echo "$SIZE_OUTPUT" | awk 'NR==2 {print $3}')

              FLASH_USAGE=$((TEXT + DATA))
              RAM_USAGE=$((DATA + BSS))

              FLASH_KB=$((FLASH_USAGE / 1024))
              RAM_KB=$((RAM_USAGE / 1024))

              echo "  Flash: ${FLASH_KB}KB (${FLASH_USAGE} bytes)"
              echo "  RAM:   ${RAM_KB}KB (${RAM_USAGE} bytes)"

              # Check limits
              if [ "$FLASH_USAGE" -gt "$MAX_FLASH" ]; then
                echo "  ❌ FLASH EXCEEDS LIMIT (max: 230KB)"
                FAILED=$((FAILED + 1))
              else
                echo "  ✓ Flash within limit"
              fi

              if [ "$RAM_USAGE" -gt "$MAX_RAM" ]; then
                echo "  ❌ RAM EXCEEDS LIMIT (max: 150KB)"
                FAILED=$((FAILED + 1))
              else
                echo "  ✓ RAM within limit"
              fi

              CHECKED=$((CHECKED + 1))
            fi
          done

          if [ $CHECKED -eq 0 ]; then
            echo ""
            echo "❌ No ELF files found in artifacts"
            exit 1
          fi

          if [ $FAILED -ne 0 ]; then
            echo ""
            echo "❌ Memory limit exceeded in $FAILED check(s)"
            exit 1
          fi

          echo ""
          echo "✅ All $CHECKED configurations within memory limits"

  status-check:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [lint, build-matrix, memory-check]
    if: always()

    steps:
      - name: Check job statuses
        run: |
          if [ "${{ needs.lint.result }}" != "success" ]; then
            echo "❌ Lint checks failed"
            exit 1
          fi
          if [ "${{ needs.build-matrix.result }}" != "success" ]; then
            echo "❌ Build matrix failed"
            exit 1
          fi
          if [ "${{ needs.memory-check.result }}" != "success" ]; then
            echo "❌ Memory check failed"
            exit 1
          fi
          echo "✅ All CI checks passed"
