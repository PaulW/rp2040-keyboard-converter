# Apple M0110 Keyboard Protocol

## Overview

The **Apple M0110 keyboard protocol** was the primary communication method used by early Macintosh computers, including the original Macintosh 128K and 512K, from 1984 to 1987. This protocol was a precursor to the more widely known **Apple Desktop Bus (ADB)** and modern **USB** standards. The M0110 system operates as a **passive polling system**, where the host Macintosh computer is always in control of the communication. The keyboard is passive; it never initiates a data transfer and only responds when the host explicitly polls it with an inquiry command. The keyboard's only active role is to drive the clock line during data transmission.

-----

## Historical Context

  - **M0110 (1984)**: This was the original, compact keyboard designed for the first Macintosh computers. Its design reflected the minimalist aesthetic of the early Macintoshes. The **M0120 numeric keypad was sold separately** and could be attached to the side of the keyboard or directly to the Mac.
  - **M0110A (1986)**: An enhanced version of the M0110, this keyboard was introduced with the Macintosh Plus and Macintosh SE. It featured a more complete layout with dedicated arrow keys and a separate numeric keypad.

The protocol's design as a **passive polling system** means that the host must continuously poll the keyboard using inquiry commands. The original Apple specification called for polls **every 250ms**, though modern implementations achieve much better responsiveness by polling immediately after each response (< 1ms latency). Without these regular polls, any key presses or releases would be lost because the keyboard has no mechanism to independently signal a state change to the host. This design choice emphasized simplicity and reliability over more complex, interrupt-driven communication.

-----

## Technical Specifications

### Physical Interface

The M0110 keyboard connects to the host via a **4-pin telephone-style RJ-10 (4P4C) cable**. The cable contains four wires: two for communication (**DATA** and **CLOCK**) and two for power (**VCC** and **GND**). The protocol uses **5V TTL logic levels** with an **open-drain configuration**, and both the DATA and CLOCK lines require external pull-up resistors to maintain a high state. These pull-ups were located on the Macintosh logic board, not in the keyboard.

### Protocol Characteristics

  - **Type**: Synchronous serial communication, where a clock signal coordinates the data transfer.
  - **Direction**: The protocol is bidirectional, but the host always initiates communication. The keyboard is strictly a passive device that only responds to commands.
  - **Clock Control**: The **keyboard exclusively drives the CLOCK line**. This is a unique feature of the protocol, as the host never drives the clock line.
  - **Data Control**: The **DATA line is bidirectional** and is driven by whichever device is currently transmitting data.
  - **Synchronization**: All data transfers are synchronous with the clock signal generated by the keyboard.
  - **Data Format**: Each transmission consists of **8 bits, sent MSB-first** (most significant bit first).
  - **Framing**: The protocol lacks conventional framing bits like start bits, parity bits, or stop bits.
  - **Initiation**: Communication is always initiated by the host.
  - **Error Handling**: The protocol relies on a **timeout-based recovery** mechanism. If the host doesn't receive a response from the keyboard within a specified time, it can retry the command.

### Timing Requirements

The protocol operates at different clock rates depending on the direction of data flow:

#### Keyboard → Host (Command Responses)

The clock frequency for data sent from the keyboard to the host is approximately **3.03 kHz**. This timing is defined by a total clock period of **330µs**, with a **160µs low phase** and a **170µs high phase**.

#### Host → Keyboard (Commands)

When the host sends commands to the keyboard, the clock frequency is approximately **2.5 kHz**. The total clock period is **400µs**, consisting of a **180µs low phase** and a **220µs high phase**.

#### Special Timing Requirements

  - **Request-to-Send**: To initiate a transmission, the host pulls the DATA line low for **840µs**.
  - **Data Hold Time**: After the final clock edge, an **80µs data hold time** is required for the keyboard to read the last bit.
  - **Response Timeout**: The host should wait no more than **500ms** for a keyboard response before timing out.

-----

## Signal Diagrams

### Receiving Data (Keyboard → Host)

This diagram shows how the host reads data from the keyboard. The keyboard drives the CLOCK line, and the host reads the DATA line on the rising edge of the clock signal.

```
        ___ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    CLK    \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
        ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
    DAT    \___X___X___X___X___X___X___X___/
             7   6   5   4   3   2   1   0

Host reads DATA on Rising Edge of CLOCK
Clock: LOW for 160µs, HIGH for 170µs
```

### Transmitting Data (Host → Keyboard)

This diagram illustrates the host sending a command to the keyboard, a process initiated by the host but clocked by the keyboard. The host's data transmission is synchronized with the keyboard's clock.

```
        _______ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _____
    CLK        \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
        ___     ___ ___ ___ ___ ___ ___ ___ ___ ___
    DAT    \___/___X___X___X___X___X___X___X___/
             * 7   6   5   4   3   2   1   0

Communication Flow (per Apple Technical Documentation):
1.  Host signals ready by pulling DATA LOW (840µs).
2.  Keyboard detects this and begins clocking.
3.  Host transmits command (MSB first) while keyboard provides clock.
4.  Last command bit leaves DATA LOW. 
5.  Host sets DATA HIGH to indicate ready to receive response.
```

-----

## Protocol Commands

The host uses a set of specific commands to communicate with the keyboard:

| Command | Value | Description | Purpose |
|---------|-------|-------------|---------|
| **Inquiry** | `0x10` | Request key transitions | This is the primary command for normal operation. The original Apple specification called for this command every 250ms, though modern implementations poll continuously (immediately after each response) for < 1ms latency. |
| **Instant** | `0x14` | Request immediate key state | This command is rarely used and requests the current, real-time status of all keys, rather than just recent changes. |
| **Model** | `0x16` | Request model identification | Used during initialization to identify the keyboard model (M0110 or M0110A) and to trigger an internal reset. |
| **Test** | `0x36` | Initiate self-test | A diagnostic command that causes the keyboard to perform a self-test. |

The Instant command was rarely used by Apple’s ROMs, but it appears in technical notes for diagnostic purposes. Most systems relied almost exclusively on Inquiry.

## Response Codes

The keyboard responds to host commands with standard codes:

| Response | Value | Binary | Description |
|----------|-------|--------|-------------|
| **Null** | `0x7B` | `0111 1011` | Indicates that there is no key activity to report. |
| **Keypad** | `0x79` | `0111 1001` | A status code indicating that an external numeric keypad has been detected. |
| **M0110 Model**| `0x0B` | `0000 1011` | The identification code for the original M0110 keyboard. |
| **M0110A Model**| `0x05` | `0000 0101` | The identification code for the enhanced M0110A keyboard. |

### Key Event Encoding

Key presses and releases are encoded in a specific way:

  - **Bits 7**: This bit is a flag that distinguishes key events from status responses. For a key event, this bit is always `0`.
  - **Bits 6-0**: These 7 bits represent the key code, which can range from `0x00` to `0x7F`.
  - **Key Release**: A key release event is signaled by taking the original key code and performing a bitwise **OR** operation with `0x80`, which sets bit 7.

For example, if `0x12` is the key code for a specific key:

  - `0x12` = **Key 0x12 pressed**
  - `0x92` = **Key 0x12 released** (calculated as `0x12 | 0x80`)

-----

## Protocol Operation

### Initialization Sequence

The protocol requires a specific sequence to establish communication after power-on:

1.  **Power-On Delay**: The host waits for **1000ms** after power-on to allow the keyboard to stabilize.
2.  **Model Command**: The host sends the `0x16` (Model Number) command.
3.  **Model Response**: The keyboard responds with its model identification code, either `0x0B` for an M0110 or `0x05` for an M0110A.
4.  **Keyboard Reset**: Sending the Model command also triggers an internal reset within the keyboard.
5.  **Normal Operation**: After receiving the model response, the host can begin the normal operation loop by sending regular Inquiry commands.

### Normal Operation Loop

The standard communication loop is a **continuous, immediate polling process** optimized for minimal latency:

1.  The keyboard responds to each Inquiry command with one of the following:
      - A **key event code** (from `0x00` to `0x7F` for a key press, or `0x80` to `0xFF` for a key release).
      - A **Null response (`0x7B`)** if there is no key activity to report.
      - A **status code** (e.g., for keypad detection).
2.  **Immediately after receiving any response**, the host sends the next **Inquiry command (`0x10`)**.
3.  The host processes the response and updates its internal representation of the keyboard's state.
4.  This creates a tight request-response loop with **< 1ms latency** between responses, far more responsive than the original 250ms polling interval.

**Note**: The original Apple specification called for inquiry commands every 250ms. However, modern implementations achieve much better responsiveness by sending inquiry commands immediately after each response, maintaining continuous communication with minimal latency.

### Error Recovery

The protocol handles errors through timeout detection and automatic retry mechanisms:

  - **Response Timeout**: If the host does not receive a response from the keyboard within **500ms**, it clears any buffered data and reinitializes the connection by returning to the UNINITIALISED state.
  - **Model Command Retry**: If the Model command fails, the host automatically retries it every **500ms** for up to **5 attempts** before giving up and restarting the detection sequence.
  - **Timeout Recovery**: The 500ms timeout indicates the keyboard is not behaving correctly (since it should always respond). The implementation clears the ring buffer and reinitializes to establish clean communication.
  - **Reset Recovery**: Since the Model command triggers a keyboard reset, it serves as both identification and a recovery mechanism to clear any internal error states.

-----

## Implementation Details

### PIO State Machine Configuration

The RP2040 PIO implementation uses these settings:

```c
// MSB-first, 8-bit frames
sm_config_set_in_shift(&c, false, true, 8);   // Shift left, autopush at 8 bits
sm_config_set_out_shift(&c, false, true, 8);  // Shift right, autopull at 8 bits

// Pin assignments
sm_config_set_jmp_pin(&c, pin + 1);     // CLOCK pin for jump conditions
sm_config_set_in_pins(&c, pin);         // DATA pin for input
sm_config_set_out_pins(&c, pin, 1);     // DATA pin for output
```

### Clock Divider Calculation

The PIO clock divider is calculated to achieve proper timing:

```c
float clock_div = calculate_clock_divider(M0110_TIMING_KEYBOARD_LOW_US);
// M0110_TIMING_KEYBOARD_LOW_US = 160µs (keyboard → host timing)
```

### State Machine States

The implementation manages these three states:

  - **UNINITIALISED**: System startup state, waiting for 1000ms initialization delay before sending first Model command
  - **INIT_MODEL_REQUEST**: Initialization phase—sending Model Number commands every 500ms with automatic retry (up to 5 attempts)
  - **INITIALISED**: Normal operation state with continuous inquiry polling and 500ms response timeout monitoring

The state machine is deliberately simple, with all protocol communication handled by the PIO hardware and interrupt-driven event processing. Commands are sent immediately in response to keyboard events, ensuring minimal latency and optimal responsiveness.

-----

## Debugging and Troubleshooting

### Common Issues

1.  **No Response from Keyboard**:
      - Check for proper physical connections for the DATA, CLOCK, and power lines.
      - Verify that pull-up resistors are correctly installed on the open-drain lines.
      - Ensure the timing parameters are correct, as the keyboard is sensitive to precise timing.
2.  **Garbled Data**:
      - Double-check the accuracy of the clock timing.
      - Confirm that the bit order is correctly set to **MSB-first**.
      - Examine the signal for electrical noise or other signal integrity issues using a logic analyzer.
3.  **Initialization Failures**:
      - If the keyboard doesn't respond to the initial Model command, increase the power-on initialization delay, as some keyboards may require more time to start up.
      - Verify that the model command sequence is being sent correctly.
      - Check for proper reset behavior after the Model command is sent.

### Signal Analysis

When debugging with a logic analyzer, look for specific signal characteristics:

  - Proper clock timing: **160µs/170µs** for data received from the keyboard (RX) and **180µs/220µs** for data transmitted to the keyboard (TX).
  - Correct DATA transitions aligned with the clock edges.
  - The **840µs DATA low period** that signals a host-initiated transmission.
  - The required **80µs data hold time** after the final clock edge.

-----

## Compatibility Notes

### Keyboard Variants

  - **Original M0110**: The original compact design without a numeric keypad.
  - **M0110A**: The enhanced version that includes arrow keys and a separate numeric keypad.

### Modern Implementations

When implementing this protocol on a modern microcontroller, such as the RP2040, it is crucial to use **hardware timers or a PIO (Programmable I/O)** module to ensure precise timing. You should also implement robust timeout handling to manage communication failures. Be aware that some keyboards may require longer initialization delays (e.g., 1-2 seconds) to become ready. Finally, it's recommended to buffer key events to prevent missing rapid key sequences.

-----

## References and Sources

1.  **Apple Technical Documentation**:
      - [Inside Macintosh Volume III (1986)](https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_III_1985.pdf) (Pages 36-40)
2.  **TMK Keyboard Firmware**:
      - [M0110 Protocol Implementation](https://github.com/tmk/tmk_keyboard/blob/master/tmk_core/protocol/m0110.c)
      - [M0110 Protocol Wiki](https://github.com/tmk/tmk_keyboard/wiki/Apple-M0110-Keyboard-Protocol)