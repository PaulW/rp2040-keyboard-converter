.program keyboard_interface
.wrap_target

; Pins: 0 = KDAT (bidirectional), 1 = KCLK (input only, keyboard-driven)

init:
    ; Wait until KCLK is HIGH before we continue (keyboard idle state)
    wait 1 pin 1

check:
    ; Wait for KCLK to go low (start of byte transmission from keyboard)
    jmp pin, check

    ; Receiving Data
    ;        ___ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _________________
    ;   KCLK    \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
    ;        ___ ___ ___ ___ ___ ___ ___ ___ ___     handshake
    ;   KDAT    \___X___X___X___X___X___X___X___\_______________/
    ;             6   5   4   3   2   1   0   7
    ;
    ; Amiga transmits bits in rotated order: 6-5-4-3-2-1-0-7
    ; Host reads KDAT on KCLK falling edge
    ; KCLK is brought LOW for ~20µs, and HIGH for ~20µs (~60µs per bit)
    ; After 8 bits, host must pulse KDAT low for 85µs (handshake)

    ; Read 8 bits (bit order: 6-5-4-3-2-1-0-7)
    set x, 7

bit_loop:
    ; Wait for KCLK falling edge
    wait 0 pin 1 [1]
    ; Read KDAT pin on falling edge
    in pins, 1
    ; Wait for KCLK rising edge
    wait 1 pin 1
    ; Decrement x and jump back to bit_loop if not zero
    jmp x--, bit_loop

    ; All 8 bits received - autopush has pushed to RX FIFO
    ; Now send handshake: pulse KDAT low for ~100µs
    ; 
    ; Handshake Timing Calculation:
    ; ==============================
    ; Clock divider calculation:
    ; - calculate_clock_divider(AMIGA_TIMING_CLOCK_MIN_US) where AMIGA_TIMING_CLOCK_MIN_US = 20µs
    ; - System clock: 125 MHz = 125,000 kHz
    ; - Target sampling: (1000 / 20µs) × 5 samples = 250 kHz
    ; - Calculated divider: 125,000 / 250 = 500
    ; - 1 PIO cycle = 4µs (125 MHz / 500)
    ; 
    ; Handshake loop structure:
    ; - Loop iterations: set x, 24 → 25 iterations (24→0)
    ; - Cycles per iteration: jmp x--, label → 1 cycle
    ; - Total cycles: 25 cycles × 4µs/cycle = 100µs
    ; 
    ; Protocol compliance:
    ; - Minimum handshake: 85µs (per protocol spec)
    ; - Implementation: 100µs (calculated)
    ; - Margin: +15µs above minimum ✓
    ; - Maximum timeout: 143ms (protocol spec)
    ; - Within limits: Yes ✓
    ; 
    ; The 100µs timing provides:
    ; 1. Compliance with 85µs minimum requirement
    ; 2. Margin for clock jitter and component tolerance
    ; 3. Fast response time for optimal keyboard responsiveness
    ; 4. Well within the 143ms maximum timeout
    ; 
    ; Hardware validation:
    ; Verified with oscilloscope measurements and tested with actual
    ; Amiga A500/A2000/A3000/A4000 keyboards.

    set pins, 0         ; Pull KDAT low
    set pindirs, 1      ; Set KDAT as output
    set x, 24           ; Loop counter for 100µs handshake (25 iterations: 24→0)

handshake_loop:
    jmp x--, handshake_loop

    set pindirs, 0      ; Release KDAT (goes high via pull-up)

    ; Continue to next byte
    jmp check

.wrap

% c-sdk {
static inline void keyboard_interface_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {
    // Pin configuration:
    // pin = KDAT (bidirectional: input for data, output for handshake)
    // pin + 1 = KCLK (input only, keyboard-driven, never drive from host)
    
    // Set both pins as inputs initially
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, false);
    
    // Initialize pins for PIO control
    pio_gpio_init(pio, pin);       // KDAT
    pio_gpio_init(pio, pin + 1);   // KCLK
    
    // Configure pull-ups (open-collector design)
    // Both keyboard and computer have pull-ups internally
    gpio_pull_up(pin);      // KDAT pull-up
    gpio_pull_up(pin + 1);  // KCLK pull-up
    
    // Get default config
    pio_sm_config c = keyboard_interface_program_get_default_config(offset);
    
    // Configure SET pins (only KDAT) for handshake pulldown
    sm_config_set_set_pins(&c, pin, 1);
    
    // Configure IN pins (for reading KDAT)
    sm_config_set_in_pins(&c, pin);
    
    // Configure JMP pin (for KCLK monitoring)
    sm_config_set_jmp_pin(&c, pin + 1);
    
    // Configure shift register for 8-bit reception
    // Left shift (MSB first) - first bit received goes to bit 7, shifts left
    // Amiga sends bits in order: 6-5-4-3-2-1-0-7
    // After left-shift reception: [6 5 4 3 2 1 0 7] (rotated format as expected)
    sm_config_set_in_shift(&c, false, true, 8);
    
    // Set clock divider for timing
    sm_config_set_clkdiv(&c, div);
    
    // Enable RX FIFO not empty interrupt
    pio_set_irq0_source_enabled(pio, pis_sm0_rx_fifo_not_empty + sm, true);
    
    // Initialize and start the state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
