.program pio_interface
; Pins: 0 = data, 1 = clock

init:
    ; Wait until CLK is high before we continue.  Keyboards seem to pull this LOW briefly
    ; during power on.  This prevents the first bit read being shifted in this scenario.
    wait 1 pin 1

check:
    ; Wait for incoming data, but jump to bitLoopOut if the Output Shift Register isn't empty
    jmp !OSRE, bitLoopOut
    jmp pin, check ; Loop back to check if pin high

    ; Receiving Data
    ;    IBM AT:
    ;        ____ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ A _ B _____
    ;    CLK     \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/
    ;        ___     ___ ___ ___ ___ ___ ___ ___ ___ ___ ________
    ;    DAT    \___/___X___X___X___X___X___X___X___X___/
    ;             S   0   1   2   3   4   5   6   7   P   s
    ;
    ;    Z-150/Other AT:
    ;        ____ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ A _ B _____  
    ;    CLK     \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/  
    ;        ___     ___ ___ ___ ___ ___ ___ ___ ___ ___     ____
    ;    DAT    \___/___X___X___X___X___X___X___X___X___\___/
    ;             S   0   1   2   3   4   5   6   7   P   s*
    ;
    ;    * Stop bit is Lo(0) 

    ; Read Start bit
    in pins, 1
    ; Wait for Clock to go High
    wait 1 pin 1

    ; Set x to 9 (to read in 8 x Data bits, 1 x Parity and 1 x Stop bit)
    set x, 9

bitLoopIn:
    ; Wait for clock signal to go low
    wait 0 pin 1 [1]
    ; Read data pin and store in pins register
    in pins, 1
    ; Wait for clock signal to go high
    wait 1 pin 1
    ; Decrement x and jump back to bitLoopIn if it's not zero
    jmp x--, bitLoopIn

    ; Jump back to check now all data read
    jmp check

bitLoopOut:
    ; Sending Data (Host → Device)
    ;    Standard AT/PS2:
    ;        __ I__R _ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ A __ B _____
    ;    CLK   \____/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/  \_/
    ;        ______     ___ ___ ___ ___ ___ ___ ___ ___ ______     ____
    ;    DAT       \___/___X___X___X___X___X___X___X___X___/  \___/
    ;           H   I R  0   1   2   3   4   5   6   7   P   s ACK
    ;
    ;    Z-150/Other AT (irregular ACK clock):
    ;        __ I__R _ 1 _ 2 _ 3 _ 4 _ 5 _ 6 _ 7 _ 8 _ 9 _ A __________
    ;    CLK   \____/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ \_/ XXXXX
    ;        ______     ___ ___ ___ ___ ___ ___ ___ ___ ______     ____
    ;    DAT       \___/___X___X___X___X___X___X___X___X___/  \___/
    ;           H   I R  0   1   2   3   4   5   6   7   P   s ACK*
    ;
    ;    Legend: H=Idle, I=Inhibit, R=RTS/Start, 0-7=Data, P=Parity, s=Stop, ACK=Acknowledge
    ;    * = Some keyboards have slow/irregular clock during ACK

    ; Host-to-Device Transmission Sequence (see README for detailed timing):
    ; 1. Inhibit: Pull CLK LOW for ~96µs (stops keyboard transmission)
    ; 2. RTS: Pull DATA LOW (Request-to-Send + Start bit)
    ; 3. Release: Set CLK to input (keyboard takes over clock generation)
    ; 4. Data: Send 8 bits + parity on keyboard clock edges
    ; 5. Stop: Pull DATA HIGH
    ; 6. ACK: Wait for keyboard to pull DATA LOW (acknowledgment)

    ; Inhibit Phase: Drive both CLK and DATA LOW for ~96µs
    ; Clock divider 750 → 6µs per cycle, 16 cycles = 96µs
    set pindirs 3 [15]  ; Set both DATA (Pin 0) and CLK (Pin 1) to output
    set pins, 0 [15]    ; Drive both LOW: CLK=Inhibit, DATA=RTS/Start Bit

    ; Release CLK, keep DATA LOW
    ; Keyboard detects CLK release and begins generating clock pulses
    set pindirs 1       ; CLK → input (released HIGH), DATA → output (LOW)

    ; Send 8 data bits + 1 parity bit (9 total from OSR, LSB first)
    ; Start bit (0) is implicit in DATA LOW state from RTS phase
    set x, 8

bitLoopOutLoop:
    ; Wait for keyboard to generate clock edges, output data bits LSB-first
    wait 0 pin 1 [1]
    out pins, 1         ; Output next bit from OSR to DATA (Pin 0)
    wait 1 pin 1
    jmp x--, bitLoopOutLoop

    ; Send Stop bit (DATA HIGH)
    wait 0 pin 1 [1]
    set pins, 1         ; Drive DATA HIGH (Stop Bit = 1)
    wait 1 pin 1

    ; Wait for ACK (keyboard pulls DATA LOW briefly)
    set pindirs, 0      ; Release DATA (set to input to read ACK)
    wait 0 pin 0 [1]
    wait 1 pin 0 [5]    ; Extra delay [5] for keyboard timing variations

    ; Transmission complete, return to idle
    jmp check

% c-sdk {
static inline void pio_interface_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {
  pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, false);
  pio_gpio_init(pio, pin);
  pio_gpio_init(pio, pin + 1);

  // Initialise pins in expected state for power up (CLK HIGH, DATA HIGH)
  // As part of initialisation on newer PS2 keyboards which support PS2>USB Dongles,
  // as-per USB spec, both DATA and CLK are low and await device to bring high.
  // AT/PS2 Specification will keep both floating HIGH when power on/connected.
  gpio_pull_up(pin);
  gpio_pull_up(pin + 1); // Ensure CLK has a pull-up too. (Correction)

  pio_sm_config c = pio_interface_program_get_default_config(offset);
  sm_config_set_set_pins(&c, pin, 2);

  sm_config_set_jmp_pin(&c, pin + 1);

  sm_config_set_in_pins(&c, pin); // for WAIT
  sm_config_set_in_shift(&c, true, true, 11);

  sm_config_set_out_pins(&c, pin, 2);
  sm_config_set_out_shift(&c, true, true, 9);

  sm_config_set_clkdiv(&c, div);

  pio_set_irq0_source_enabled(pio, pis_sm0_rx_fifo_not_empty + sm, true);

  pio_sm_init(pio, sm, offset, &c);

  pio_sm_set_enabled(pio, sm, true);
}
%}